[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/BotFacade.js",
    "content": "import { Bot as BotServer } from './Bot';\nlet botServer;\n/**\n * Bot server may be a member of severals groups. Each group is isolated.\n * He can be invited by a group member via {@link WebGroup#invite} method.\n * @example\n * // In NodeJS:\n * // Create a bot server with full mesh topology, without autorejoin feature\n * // and with specified Signaling and ICE servers for WebRTC.\n * // Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n *\n * const http = require('http')\n * const server = http.createServer()\n * const bot = new Bot({\n *   server,\n *   webGroupOptions: {\n *     signalingServer: 'wss://mysignaling.com',\n *     rtcConfiguration: {\n *       iceServers: [\n *         {\n *           urls: 'stun.l.google.com:19302'\n *         },\n *         {\n *           urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *           username: 'user',\n *           password: 'password'\n *         }\n *       ]\n *     }\n *   }\n * })\n *\n * bot.onWebGroup = (wg) => {\n *   // YOUR CODE\n * }\n *\n * bot.onError = (err) => {\n *   // YOUR CODE\n * }\n *\n * server.listen(BOT_PORT, BOT_HOST)\n */\nexport class Bot {\n    /**\n     * @param {BotOptions} options\n     * @param {NodeJSHttpServer|NodeJSHttpsServer} options.server NodeJS http(s) server.\n     * @param {string} [options.url] Bot server URL.\n     * @param {boolean} [options.perMessageDeflate=false] Enable/disable permessage-deflate.\n     * @param {boolean} [options.leaveOnceAlone=false] If true, bot will live (disconnect from the signaling server) if no other peers left in the group.\n     * @param {WebGroupOptions} options.webGroupOptions Options for each {@link WebGroup} the bot is member of.\n     * @param {Topology} [options.webGroupOptions.topology=Topology.FULL_MESH]\n     * @param {string} [options.webGroupOptions.signalingServer='wss://signaling.netflux.coedit.re']\n     * @param {RTCConfiguration} [options.webGroupOptions.rtcConfiguration={iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}]\n     * @param {boolean} [options.webGroupOptions.autoRejoin=true]\n     */\n    constructor(options) {\n        botServer = new BotServer(options);\n        /**\n         * Read-only NodeJS http server instance.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.server = undefined;\n        Reflect.defineProperty(this, 'server', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.server,\n        });\n        /**\n         * Read-only property of WebSocket server: permessage-deflate.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.perMessageDeflate = undefined;\n        Reflect.defineProperty(this, 'perMessageDeflate', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.perMessageDeflate,\n        });\n        /**\n         * Read-only property leaveOnceAlone.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.leaveOnceAlone = undefined;\n        Reflect.defineProperty(this, 'leaveOnceAlone', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.leaveOnceAlone,\n        });\n        /**\n         * Read-only set of web groups the bot is member of.\n         * @type {Set<WebGroup>}\n         */\n        this.webGroups = undefined;\n        Reflect.defineProperty(this, 'webGroups', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.webGroups,\n        });\n        /**\n         * Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.\n         * @type {string}\n         */\n        this.url = undefined;\n        Reflect.defineProperty(this, 'url', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.url,\n        });\n        /**\n         * This handler is called when the bot has been invited into a group by one of its members.\n         * @type  {function(wg: WebGroup)} handler\n         */\n        this.onWebGroup = undefined;\n        Reflect.defineProperty(this, 'onWebGroup', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onWebGroup.name === 'none' ? undefined : botServer.onWebGroup),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onWebGroup = function none() { };\n                }\n                else {\n                    botServer.onWebGroup = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when an error occurs on WebSocket server.\n         * @type  {function(err: Error)}\n         */\n        this.onError = undefined;\n        Reflect.defineProperty(this, 'onError', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onError.name === 'none' ? undefined : botServer.onError),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onError = function none() { };\n                }\n                else {\n                    botServer.onError = handler;\n                }\n            },\n        });\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/BotFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "Bot",
    "memberof": "src/BotFacade.js",
    "static": true,
    "longname": "src/BotFacade.js~Bot",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/BotFacade.js",
    "importStyle": "{Bot}",
    "description": "Bot server may be a member of severals groups. Each group is isolated.\nHe can be invited by a group member via {@link WebGroup#invite} method.",
    "examples": [
      "// In NodeJS:\n// Create a bot server with full mesh topology, without autorejoin feature\n// and with specified Signaling and ICE servers for WebRTC.\n// Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n\nconst http = require('http')\nconst server = http.createServer()\nconst bot = new Bot({\n  server,\n  webGroupOptions: {\n    signalingServer: 'wss://mysignaling.com',\n    rtcConfiguration: {\n      iceServers: [\n        {\n          urls: 'stun.l.google.com:19302'\n        },\n        {\n          urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n          username: 'user',\n          password: 'password'\n        }\n      ]\n    }\n  }\n})\n\nbot.onWebGroup = (wg) => {\n  // YOUR CODE\n}\n\nbot.onError = (err) => {\n  // YOUR CODE\n}\n\nserver.listen(BOT_PORT, BOT_HOST)"
    ],
    "lineNumber": 43,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/BotFacade.js~Bot",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/BotFacade.js~Bot#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "BotOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "options.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.leaveOnceAlone",
        "description": "If true, bot will live (disconnect from the signaling server) if no other peers left in the group."
      },
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options.webGroupOptions",
        "description": "Options for each {@link WebGroup} the bot is member of."
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.webGroupOptions.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://signaling.netflux.coedit.re'",
        "defaultRaw": "'wss://signaling.netflux.coedit.re'",
        "name": "options.webGroupOptions.signalingServer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "defaultRaw": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "name": "options.webGroupOptions.rtcConfiguration",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.webGroupOptions.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "server",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#server",
    "access": "public",
    "description": "Read-only NodeJS http server instance.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "perMessageDeflate",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#perMessageDeflate",
    "access": "public",
    "description": "Read-only property of WebSocket server: permessage-deflate.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "leaveOnceAlone",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#leaveOnceAlone",
    "access": "public",
    "description": "Read-only property leaveOnceAlone.",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "webGroups",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#webGroups",
    "access": "public",
    "description": "Read-only set of web groups the bot is member of.",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Set<WebGroup>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "url",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#url",
    "access": "public",
    "description": "Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.",
    "lineNumber": 102,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 8,
    "kind": "member",
    "name": "onWebGroup",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#onWebGroup",
    "access": "public",
    "description": "This handler is called when the bot has been invited into a group by one of its members.",
    "lineNumber": 112,
    "type": {
      "nullable": null,
      "types": [
        "function(wg: WebGroup)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 9,
    "kind": "member",
    "name": "onError",
    "memberof": "src/BotFacade.js~Bot",
    "static": false,
    "longname": "src/BotFacade.js~Bot#onError",
    "access": "public",
    "description": "This handler is called when an error occurs on WebSocket server.",
    "lineNumber": 130,
    "type": {
      "nullable": null,
      "types": [
        "function(err: Error)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 10,
    "kind": "file",
    "name": "src/WebChannelFacade.js",
    "content": "import { WebChannel } from './WebChannel';\n/**\n * Is a helper type representing types that can be sent/received over a web group.\n * @typedef {string|Uint8Array} DataType\n */\n/**\n * @ignore\n */\nexport const wcs = new WeakMap();\n/**\n * This class is an API starting point. It represents a peer to peer network,\n * simply called a group. Each group member can send/receive broadcast\n * as well as personal messages, invite other persons or bots (see {@link Bot}).\n * @example\n * // Create a WebGroup with full mesh topology, autorejoin feature and\n * // specified Signaling and ICE servers for WebRTC.\n *\n * const wg = new WebGroup({\n *   signalingServer: 'wss://mysignaling.com',\n *   rtcConfiguration: {\n *     iceServers: [\n *       {\n *         urls: 'stun.l.google.com:19302'\n *       },\n *       {\n *         urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *         username: 'user',\n *         password: 'password'\n *       }\n *     ]\n *   }\n * })\n *\n * wg.onMemberJoin = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMemberLeave = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMessage = (id, data) => {\n *   // YOUR CODE...\n * }\n * wg.onStateChange = (state) => {\n *   // YOUR CODE...\n * }\n * wg.onSignalingStateChange = (state) => {\n *   // YOUR CODE...\n * }\n */\nexport class WebGroup {\n    /**\n     * @param {WebGroupOptions} [options]\n     * @param {Topology} [options.topology=Topology.FULL_MESH]\n     * @param {string} [options.signalingServer='wss://signaling.netflux.coedit.re']\n     * @param {RTCConfiguration} [options.rtcConfiguration={iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}]\n     * @param {boolean} [options.autoRejoin=true]\n     */\n    constructor(options = {}) {\n        const wc = new WebChannel(options);\n        wcs.set(this, wc);\n        /**\n         * The read-only {@link WebGroup} identifier. The same value for all members.\n         * @type {number}\n         */\n        this.id = undefined;\n        Reflect.defineProperty(this, 'id', { configurable: false, enumerable: true, get: () => wc.id });\n        /**\n         * The read-only your unique member identifier in the group.\n         * @type {number}\n         */\n        this.myId = undefined;\n        Reflect.defineProperty(this, 'myId', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.myId,\n        });\n        /**\n         * The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\n         * Different to {@link WebGroup#id}. This key is known and used by Signaling server\n         * in order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.\n         * @type {string}\n         */\n        this.key = undefined;\n        Reflect.defineProperty(this, 'key', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.key,\n        });\n        /**\n         * The read-only array of all members including yourself (i.e. {@link WebGroup#myId})\n         * @type {number[]}\n         */\n        this.members = undefined;\n        Reflect.defineProperty(this, 'members', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.members,\n        });\n        /**\n         * The read-only array of neighbor members (i.e. members who are directly connected to you). Hence they are included in the {@link WebGroup#members} by definition.\n         * @type {number[]}\n         */\n        this.neighbors = undefined;\n        Reflect.defineProperty(this, 'neighbors', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.topology.neighbors.map((ch) => ch.id),\n        });\n        /**\n         * The read-only property which is an enum of type {@link Topology}\n         * indicating the topology used for this {@link WebGroup} instance.\n         * @type {Topology}\n         */\n        this.topology = undefined;\n        Reflect.defineProperty(this, 'topology', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.topologyEnum,\n        });\n        /**\n         * The read-only state of the {@link WebGroup} connection.\n         * @type {WebGroupState}\n         */\n        this.state = undefined;\n        Reflect.defineProperty(this, 'state', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.state,\n        });\n        /**\n         * The read-only state of the signaling server.\n         * @type {SignalingState}\n         */\n        this.signalingState = undefined;\n        Reflect.defineProperty(this, 'signalingState', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.signaling.state,\n        });\n        /**\n         * The read-only signaling server URL.\n         * @type {string}\n         */\n        this.signalingServer = undefined;\n        Reflect.defineProperty(this, 'signalingServer', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.signaling.url,\n        });\n        /**\n         * Enable/Desable the auto rejoin feature.\n         * @type {boolean}\n         */\n        this.autoRejoin = undefined;\n        Reflect.defineProperty(this, 'autoRejoin', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.autoRejoin,\n            set: (value) => (wc.autoRejoin = value),\n        });\n        /**\n         * This handler is called when a message has been received from the group.\n         * `id` is an identifier of the member who sent this message.\n         * and false if sent via {@link WebGroup#sendTo}.\n         * @type {function(id: number, data: DataType)}\n         */\n        this.onMessage = undefined;\n        Reflect.defineProperty(this, 'onMessage', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMessage.name === 'none' ? undefined : wc.onMessage),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMessage = function none() { };\n                }\n                else {\n                    wc.onMessage = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a new member with `id` as identifier has joined the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberJoin = undefined;\n        Reflect.defineProperty(this, 'onMemberJoin', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberJoin.name === 'none' ? undefined : wc.onMemberJoin),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberJoin = function none() { };\n                }\n                else {\n                    wc.onMemberJoin = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a member with `id` as identifier hes left the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberLeave = undefined;\n        Reflect.defineProperty(this, 'onMemberLeave', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberLeave.name === 'none' ? undefined : wc.onMemberLeave),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberLeave = function none() { };\n                }\n                else {\n                    wc.onMemberLeave = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the group state has changed.\n         * @type {function(state: WebGroupState)}\n         */\n        this.onStateChange = undefined;\n        Reflect.defineProperty(this, 'onStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onStateChange.name === 'none' ? undefined : wc.onStateChange),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onStateChange = function none() { };\n                }\n                else {\n                    wc.onStateChange = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the signaling state has changed.\n         * @type {function(state: SignalingState)}\n         */\n        this.onSignalingStateChange = undefined;\n        Reflect.defineProperty(this, 'onSignalingStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => wc.onSignalingStateChange.name === 'none' ? undefined : wc.onSignalingStateChange,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onSignalingStateChange = function none() { };\n                }\n                else {\n                    wc.onSignalingStateChange = handler;\n                }\n            },\n        });\n    }\n    /**\n     * Join the group identified by a key provided by one of the group member.\n     * If the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n     * {@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\n     * then do nothing.\n     * @param {string} [key] Will be generated if not provided\n     */\n    join(key) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.join(key);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Invite a bot server to join this group.\n     * @param {string} url - Bot server URL (See {@link BotOptions})\n     */\n    invite(url) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.invite(url);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Leave the group which means close channels with all members and connection\n     * with the Signaling server.\n     */\n    leave() {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.leave();\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Broadcast a message to the group.\n     * @param {DataType} data\n     */\n    send(data) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.send(data);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Send a message to a particular group member.\n     * @param {number}    id Member identifier\n     * @param {DataType}  data Message\n     */\n    sendTo(id, data) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.sendTo(id, data);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/WebChannelFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 11,
    "kind": "typedef",
    "name": "DataType",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~DataType",
    "access": "public",
    "description": "Is a helper type representing types that can be sent/received over a web group.",
    "type": {
      "types": [
        "string",
        "Uint8Array"
      ],
      "optional": false,
      "name": "DataType"
    }
  },
  {
    "__docId__": 12,
    "kind": "variable",
    "name": "wcs",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~wcs",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{wcs}",
    "description": "",
    "lineNumber": 9,
    "ignore": true
  },
  {
    "__docId__": 13,
    "kind": "class",
    "name": "WebGroup",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroup",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{WebGroup}",
    "description": "This class is an API starting point. It represents a peer to peer network,\nsimply called a group. Each group member can send/receive broadcast\nas well as personal messages, invite other persons or bots (see {@link Bot}).",
    "examples": [
      "// Create a WebGroup with full mesh topology, autorejoin feature and\n// specified Signaling and ICE servers for WebRTC.\n\nconst wg = new WebGroup({\n  signalingServer: 'wss://mysignaling.com',\n  rtcConfiguration: {\n    iceServers: [\n      {\n        urls: 'stun.l.google.com:19302'\n      },\n      {\n        urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n\nwg.onMemberJoin = (id) => {\n  // YOUR CODE...\n}\nwg.onMemberLeave = (id) => {\n  // YOUR CODE...\n}\nwg.onMessage = (id, data) => {\n  // YOUR CODE...\n}\nwg.onStateChange = (state) => {\n  // YOUR CODE...\n}\nwg.onSignalingStateChange = (state) => {\n  // YOUR CODE...\n}"
    ],
    "lineNumber": 50,
    "interface": false
  },
  {
    "__docId__": 14,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://signaling.netflux.coedit.re'",
        "defaultRaw": "'wss://signaling.netflux.coedit.re'",
        "name": "options.signalingServer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "defaultRaw": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "name": "options.rtcConfiguration",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 15,
    "kind": "member",
    "name": "id",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#id",
    "access": "public",
    "description": "The read-only {@link WebGroup} identifier. The same value for all members.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 16,
    "kind": "member",
    "name": "myId",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#myId",
    "access": "public",
    "description": "The read-only your unique member identifier in the group.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 17,
    "kind": "member",
    "name": "key",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#key",
    "access": "public",
    "description": "The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\nDifferent to {@link WebGroup#id}. This key is known and used by Signaling server\nin order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 18,
    "kind": "member",
    "name": "members",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#members",
    "access": "public",
    "description": "The read-only array of all members including yourself (i.e. {@link WebGroup#myId})",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 19,
    "kind": "member",
    "name": "neighbors",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#neighbors",
    "access": "public",
    "description": "The read-only array of neighbor members (i.e. members who are directly connected to you). Hence they are included in the {@link WebGroup#members} by definition.",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 20,
    "kind": "member",
    "name": "topology",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#topology",
    "access": "public",
    "description": "The read-only property which is an enum of type {@link Topology}\nindicating the topology used for this {@link WebGroup} instance.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "Topology"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 21,
    "kind": "member",
    "name": "state",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#state",
    "access": "public",
    "description": "The read-only state of the {@link WebGroup} connection.",
    "lineNumber": 124,
    "type": {
      "nullable": null,
      "types": [
        "WebGroupState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 22,
    "kind": "member",
    "name": "signalingState",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingState",
    "access": "public",
    "description": "The read-only state of the signaling server.",
    "lineNumber": 134,
    "type": {
      "nullable": null,
      "types": [
        "SignalingState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "signalingServer",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingServer",
    "access": "public",
    "description": "The read-only signaling server URL.",
    "lineNumber": 144,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "autoRejoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#autoRejoin",
    "access": "public",
    "description": "Enable/Desable the auto rejoin feature.",
    "lineNumber": 154,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "onMessage",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMessage",
    "access": "public",
    "description": "This handler is called when a message has been received from the group.\n`id` is an identifier of the member who sent this message.\nand false if sent via {@link WebGroup#sendTo}.",
    "lineNumber": 167,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number, data: DataType)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "name": "onMemberJoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberJoin",
    "access": "public",
    "description": "This handler is called when a new member with `id` as identifier has joined the group.",
    "lineNumber": 185,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 27,
    "kind": "member",
    "name": "onMemberLeave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberLeave",
    "access": "public",
    "description": "This handler is called when a member with `id` as identifier hes left the group.",
    "lineNumber": 203,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 28,
    "kind": "member",
    "name": "onStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onStateChange",
    "access": "public",
    "description": "This handler is called when the group state has changed.",
    "lineNumber": 221,
    "type": {
      "nullable": null,
      "types": [
        "function(state: WebGroupState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 29,
    "kind": "member",
    "name": "onSignalingStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onSignalingStateChange",
    "access": "public",
    "description": "This handler is called when the signaling state has changed.",
    "lineNumber": 239,
    "type": {
      "nullable": null,
      "types": [
        "function(state: SignalingState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 30,
    "kind": "method",
    "name": "join",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#join",
    "access": "public",
    "description": "Join the group identified by a key provided by one of the group member.\nIf the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n{@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\nthen do nothing.",
    "lineNumber": 261,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "Will be generated if not provided"
      }
    ]
  },
  {
    "__docId__": 31,
    "kind": "method",
    "name": "invite",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#invite",
    "access": "public",
    "description": "Invite a bot server to join this group.",
    "lineNumber": 272,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Bot server URL (See {@link BotOptions})"
      }
    ]
  },
  {
    "__docId__": 32,
    "kind": "method",
    "name": "leave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#leave",
    "access": "public",
    "description": "Leave the group which means close channels with all members and connection\nwith the Signaling server.",
    "lineNumber": 283
  },
  {
    "__docId__": 33,
    "kind": "method",
    "name": "send",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#send",
    "access": "public",
    "description": "Broadcast a message to the group.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 34,
    "kind": "method",
    "name": "sendTo",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#sendTo",
    "access": "public",
    "description": "Send a message to a particular group member.",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Member identifier"
      },
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Message"
      }
    ]
  },
  {
    "__docId__": 35,
    "kind": "file",
    "name": "src/index.common.doc.js",
    "content": "import { LogLevel as Logs, setLogLevel as setLogs } from './misc/util';\nimport { TopologyEnum } from './service/topology/Topology';\nimport { SignalingState as SigState } from './Signaling';\nimport { WebChannelState } from './WebChannelState';\nexport { WebGroup } from './WebChannelFacade';\n/**\n * Set log level for debugging utility. By default all logs are disabled.\n * @param {...LogLevel} levels\n */\nexport function setLogLevel(...levels) {\n    setLogs(...levels);\n}\n/**\n * The state enum of the signaling server.\n */\nexport class SignalingState {\n    /**\n     * `0`: the connection is not yet open (equivalent to `WebSocket.CONNECTING`).\n     * @type {number}\n     */\n    static get CONNECTING() {\n        return SigState.CONNECTING;\n    }\n    /**\n     * `1`: the connection is open and ready to communicate (equivalent to `WebSocket.OPEN`).\n     * @type {number}\n     */\n    static get OPEN() {\n        return SigState.OPEN;\n    }\n    /**\n     * `3`: the connection is closed or couldn't be opened (equivalent to `WebSocket.CLOSED`).\n     * @type {number}\n     */\n    static get CLOSED() {\n        return SigState.CLOSED;\n    }\n    /**\n     * `2`: signaling server is checking wether you are still connected to the group. If it is not the case, then\n     * subscribs you to one of the group member in order to create a connection with him.\n     * @type {number}\n     */\n    static get CHECKING() {\n        return SigState.CHECKING;\n    }\n    /**\n     * `4`: a connection has been established with one of the group member or you are the only member of the group.\n     * From now the signaling is no longer needed, because the joining process will continue with a help of this member.\n     * @type {number}\n     */\n    static get CHECKED() {\n        return SigState.CHECKED;\n    }\n}\n/**\n * The state enum of {@link WebGroup}.\n */\nexport class WebGroupState {\n    /**\n     * `0`: you haven't joined the group yet.\n     * @type {number}\n     */\n    static get JOINING() {\n        return WebChannelState.JOINING;\n    }\n    /**\n     * `1`: you have sussessfully joined the group and ready to communicate.\n     * @type {number}\n     */\n    static get JOINED() {\n        return WebChannelState.JOINED;\n    }\n    /**\n     * `3`: you have sussessfully left the group.\n     * @type {number}\n     */\n    static get LEFT() {\n        return WebChannelState.LEFT;\n    }\n}\n/**\n * The topology enum. More topologies will be added in the future\n */\nexport class Topology {\n    /**\n     * Full mesh topology identifier.\n     * @type {number}\n     */\n    static get FULL_MESH() {\n        return TopologyEnum.FULL_MESH;\n    }\n}\n/**\n * The log level enum for debugging purposes.\n */\nexport class LogLevel {\n    /**\n     * Equals to `1`, allows logs for debug.\n     * @type {number}\n     */\n    static get DEBUG() {\n        return Logs.DEBUG;\n    }\n    /**\n     * Equals to `2`, logs for WebGroup module.\n     * @type {number}\n     */\n    static get WEB_GROUP() {\n        return Logs.WEB_GROUP;\n    }\n    /**\n     * Equals to `3`, logs for DataChannelBuilder module.\n     * @type {number}\n     */\n    static get WEBRTC() {\n        return Logs.WEBRTC;\n    }\n    /**\n     * Equals to `4`, logs for Channel module.\n     * @type {number}\n     */\n    static get CHANNEL() {\n        return Logs.CHANNEL;\n    }\n    /**\n     * Equals to `5`, logs for Topology module.\n     * @type {number}\n     */\n    static get TOPOLOGY() {\n        return Logs.TOPOLOGY;\n    }\n    /**\n     * Equals to `6`, logs for Signaling module.\n     * @type {number}\n     */\n    static get SIGNALING() {\n        return Logs.SIGNALING;\n    }\n    /**\n     * Equals to `7`, logs for ChannelBuilder module.\n     * @type {number}\n     */\n    static get CHANNEL_BUILDER() {\n        return Logs.CHANNEL_BUILDER;\n    }\n}\n/**\n * The options to be passed into {@link WebGroup} constructor.\n * @typedef {Object} WebGroupOptions\n * @property {Topology} [topology] Topology identifier\n * (Full mesh is the only one supported by Netflux for now).\n * @property {string} [signalingServer] Signaling URL for WebRTC.\n * @property {RTCConfiguration} [rtcConfiguration] Configuration for WebRTC.\n * @property {boolean} [autoRejoin] Whether to automatically rejoin the web group\n * on disconnect or not. Its value may be modified after {@link WebGroup}\n * instantiation at any time.\n */\n/**\n * The options to be passed into {@link Bot} constructor.\n * @typedef {Object} BotOptions\n * @property {Topology} [topology] See WebGroupOptions.topology\n * @property {string} [signalingServer] See WebGroupOptions.signalingServer\n * @property {RTCConfiguration} [rtcConfiguration] See WebGroupOptions.rtcConfiguration\n * @property {boolean} [autoRejoin] See WebGroupOptions.autoRejoin\n * @property {Object} bot Server related options of the bot.\n * @property {NodeJSHttpServer|NodeJSHttpsServer} bot.server NodeJS http(s) server.\n * @property {string} [bot.url] Bot server URL.\n * @property {boolean} [bot.perMessageDeflate] Enable/disable permessage-deflate.\n * @property {boolean} [bot.leaveOnceAlone] If true, bot will live (disconnect from the signaling server) if no other peers left in the group.\n */\n/**\n * @external {RTCConfiguration} https://developer.mozilla.org/en/docs/Web/API/RTCConfiguration\n */\n/**\n * @external {Uint8Array} https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n */\n/**\n * @external {NodeJSHttpServer} https://nodejs.org/api/http.html#http_class_http_server\n */\n/**\n * @external {NodeJSHttpsServer} https://nodejs.org/api/https.html#https_class_https_server\n */\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/index.common.doc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 36,
    "kind": "function",
    "name": "setLogLevel",
    "memberof": "src/index.common.doc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~setLogLevel",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{setLogLevel}",
    "description": "Set log level for debugging utility. By default all logs are disabled.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "...LogLevel"
        ],
        "spread": true,
        "optional": false,
        "name": "levels",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 37,
    "kind": "class",
    "name": "SignalingState",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{SignalingState}",
    "description": "The state enum of the signaling server.",
    "lineNumber": 16,
    "interface": false
  },
  {
    "__docId__": 38,
    "kind": "get",
    "name": "CONNECTING",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CONNECTING",
    "access": "public",
    "description": "`0`: the connection is not yet open (equivalent to `WebSocket.CONNECTING`).",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 39,
    "kind": "get",
    "name": "OPEN",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.OPEN",
    "access": "public",
    "description": "`1`: the connection is open and ready to communicate (equivalent to `WebSocket.OPEN`).",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 40,
    "kind": "get",
    "name": "CLOSED",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CLOSED",
    "access": "public",
    "description": "`3`: the connection is closed or couldn't be opened (equivalent to `WebSocket.CLOSED`).",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 41,
    "kind": "get",
    "name": "CHECKING",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CHECKING",
    "access": "public",
    "description": "`2`: signaling server is checking wether you are still connected to the group. If it is not the case, then\nsubscribs you to one of the group member in order to create a connection with him.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 42,
    "kind": "get",
    "name": "CHECKED",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CHECKED",
    "access": "public",
    "description": "`4`: a connection has been established with one of the group member or you are the only member of the group.\nFrom now the signaling is no longer needed, because the joining process will continue with a help of this member.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 43,
    "kind": "class",
    "name": "WebGroupState",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{WebGroupState}",
    "description": "The state enum of {@link WebGroup}.",
    "lineNumber": 58,
    "interface": false
  },
  {
    "__docId__": 44,
    "kind": "get",
    "name": "JOINING",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.JOINING",
    "access": "public",
    "description": "`0`: you haven't joined the group yet.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 45,
    "kind": "get",
    "name": "JOINED",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.JOINED",
    "access": "public",
    "description": "`1`: you have sussessfully joined the group and ready to communicate.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 46,
    "kind": "get",
    "name": "LEFT",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.LEFT",
    "access": "public",
    "description": "`3`: you have sussessfully left the group.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 47,
    "kind": "class",
    "name": "Topology",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~Topology",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{Topology}",
    "description": "The topology enum. More topologies will be added in the future",
    "lineNumber": 84,
    "interface": false
  },
  {
    "__docId__": 48,
    "kind": "get",
    "name": "FULL_MESH",
    "memberof": "src/index.common.doc.js~Topology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~Topology.FULL_MESH",
    "access": "public",
    "description": "Full mesh topology identifier.",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "LogLevel",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{LogLevel}",
    "description": "The log level enum for debugging purposes.",
    "lineNumber": 96,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "typedef",
    "name": "WebGroupOptions",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroup} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "Topology identifier\n(Full mesh is the only one supported by Netflux for now)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingServer",
        "description": "Signaling URL for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "name": "rtcConfiguration",
        "description": "Configuration for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "Whether to automatically rejoin the web group\non disconnect or not. Its value may be modified after {@link WebGroup}\ninstantiation at any time."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupOptions"
    }
  },
  {
    "__docId__": 51,
    "kind": "typedef",
    "name": "BotOptions",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~BotOptions",
    "access": "public",
    "description": "The options to be passed into {@link Bot} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "See WebGroupOptions.topology"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingServer",
        "description": "See WebGroupOptions.signalingServer"
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "name": "rtcConfiguration",
        "description": "See WebGroupOptions.rtcConfiguration"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "See WebGroupOptions.autoRejoin"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bot",
        "description": "Server related options of the bot."
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "bot.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.leaveOnceAlone",
        "description": "If true, bot will live (disconnect from the signaling server) if no other peers left in the group."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "BotOptions"
    }
  },
  {
    "__docId__": 52,
    "kind": "external",
    "name": "RTCConfiguration",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/RTCConfiguration",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~RTCConfiguration",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 53,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~Uint8Array",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 54,
    "kind": "external",
    "name": "NodeJSHttpServer",
    "externalLink": "https://nodejs.org/api/http.html#http_class_http_server",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~NodeJSHttpServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 55,
    "kind": "external",
    "name": "NodeJSHttpsServer",
    "externalLink": "https://nodejs.org/api/https.html#https_class_https_server",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~NodeJSHttpsServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 56,
    "kind": "get",
    "name": "DEBUG",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.DEBUG",
    "access": "public",
    "description": "Equals to `1`, allows logs for debug.",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "get",
    "name": "WEB_GROUP",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.WEB_GROUP",
    "access": "public",
    "description": "Equals to `2`, logs for WebGroup module.",
    "lineNumber": 108,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "get",
    "name": "WEBRTC",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.WEBRTC",
    "access": "public",
    "description": "Equals to `3`, logs for DataChannelBuilder module.",
    "lineNumber": 115,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "get",
    "name": "CHANNEL",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.CHANNEL",
    "access": "public",
    "description": "Equals to `4`, logs for Channel module.",
    "lineNumber": 122,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "get",
    "name": "TOPOLOGY",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.TOPOLOGY",
    "access": "public",
    "description": "Equals to `5`, logs for Topology module.",
    "lineNumber": 129,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 61,
    "kind": "get",
    "name": "SIGNALING",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.SIGNALING",
    "access": "public",
    "description": "Equals to `6`, logs for Signaling module.",
    "lineNumber": 136,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 62,
    "kind": "get",
    "name": "CHANNEL_BUILDER",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.CHANNEL_BUILDER",
    "access": "public",
    "description": "Equals to `7`, logs for ChannelBuilder module.",
    "lineNumber": 143,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "index",
    "content": "# Netflux\n\n![Netflux logo][logo]\n\nUniversal Javascript **peer to peer** transport API for client and server.\n\nSecure and fault tolerant full mesh peer to peer network based on **RTCDataChannel** and **WebSocket**.\n\nSend/receive **String** and **Uint8Array** data types.\n\nDocumentation: <https://coast-team.github.io/netflux>\n\n[![version](https://img.shields.io/npm/v/netflux.svg?style=flat-square)](https://www.npmjs.com/package/netflux)\n[![travis](https://travis-ci.org/coast-team/netflux.svg?branch=master)](https://travis-ci.org/coast-team/netflux)\n\n[![codeclimate](https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg)](https://codeclimate.com/github/coast-team/netflux)\n[![Test Coverage](https://api.codeclimate.com/v1/badges/65c5d6308e7e58edd7b0/test_coverage)](https://codeclimate.com/github/coast-team/netflux/test_coverage)\n[![documentation](https://coast-team.github.io/netflux/badge.svg)](https://coast-team.github.io/netflux)\n\n[![Conventional Changelog](https://img.shields.io/badge/changelog-conventional-brightgreen.svg?)](http://conventional-changelog.github.io)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square)](https://github.com/semantic-release/semantic-release)\n[![gitter](https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square)](https://gitter.im/coast-team/netflux?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n![Netflux example][netflux_example]\n\n## Features\n\n- Peer to peer full mesh network which accepts connection failures between some peers.\n- If connection between two members failed, other members will retransmit messages for them.\n- Automatic rejoin the group if connection lost.\n- Automatic selection between [WebSocket][websocket] & [RTCDataChannel][rtcdatachannel].\n- Possible to have mixed members: clients (Chrome, Firefox) and servers (NodeJS bot).\n- Send private or broadcast [String][string], [Uint8Array][uint8array] data types.\n- Possible to send data > 1MB.\n- All connections are encrypted.\n- Full control over WebRTC servers: Signaling, STUN and TURN.\n  - Deploy your own Signaling server ([Sigver][sigver]) or use one provided by default.\n  - Configure STUN and TURN servers.\n- Small Signaling server payload.\n- Signaling server is used only to establish connection between two peers, no user data is passing through it.\n- Universal API (works in Chrome/Firefox and NodeJS).\n- TypeScript declaration files are included.\n- Simple and familiar API usage.\n- 4 builds (ES5 code):\n  - `dist/netflux.cjs.js` CommonJS format for NodeJS (see _package.json#main_).\n  - `dist/esm/index.node.js` ES module format for NodeJS (see _package.json#module_).\n  - `dist/esm/index.browser.js` ES module format for browsers (see _package.json#browser_).\n  - `dist/netflux.umd.js` UMD format for browsers.\n\n## Install\n\n```shell\nnpm install netflux\n```\n\n## Usage\n\nHere is a basic usage example for client and server (checkout the [documenation](https://coast-team.github.io/netflux) for more details).\n\n> It is possible to have only clients without any bot server as his is not a mandatory member, but like any other group member.\n\n### Client example\n\n```javascript\nimport { WebGroup, WebGroupState } from 'netflux'\n\n// Create instance and set callbacks\nconst wg = new WebGroup()\n\nwg.onMemberJoin = (id) => {\n  console.log(`Member ${id} has joined. Current members list is: `, wg.members)\n  // Say hello to the new peer\n  wg.sendTo(id, 'Hello, my name is Bob')\n}\n\nwg.onMemberLeave = (id) => {\n  console.log(`Member ${id} has left. Remained members are: `, wg.members)\n}\n\nwg.onMessage = (id, data) => {\n  console.log(`Message from ${id} group member`, data)\n}\n\nwg.onStateChange = (state) => {\n  console.log('The new Group state is ', state)\n  switch (state) {\n    case WebGroupState.JOINING:\n      // Do something\n      break\n    case WebGroupState.JOINED:\n      // Do something... for example invite a bot...\n      wg.invite('BOT_SERVER_WEB_SOCKET_URL')\n      // Or send message to all peers\n      wg.send('Hello everybody. I have just joined the group.')\n      break\n    case WebGroupState.LEFT:\n      // wg.key === ''\n      // wg.id === 0\n      // wg.myId === 0\n      // wg.members === []\n      // the current wg object is at the same state as if it was instantiated via new WebGroup(...), hence\n      // it can be reused to join another group for example.\n      // Do something...\n      break\n  }\n}\n\n// Join the group\nwg.join('MY_UNIQUE_KEY_FOR_THE_GROUP')\n```\n\n### Bot example\n\n```javascript\nimport { Bot, WebGroupState } from 'netflux'\nconst http = require('http') // https is also possible\nconst server = http.createServer()\n\nconst bot = new WebGroupBotServer({\n  server: server,\n  webGroupOptions: {\n    // Any WebGroup options like for a client\n  },\n})\n\nbot.onWebGroup = (wg) => {\n  console.log('The current state is JOINING: ', wg.state === WebGroupState.JOINING)\n  // New instance of a WebGroup (Someone has invited this bot).\n  // See example above for client as it is the same API.\n}\n\nserver.listen(BOT_PORT, _BOT_HOST)\n// A client may invite this bot with the following URL: 'ws://BOT_HOST:BOT_PORT'\n```\n\n## Demo\n\nNetflux is used by our team for Multi User Text Editor ([MUTE repo](https://github.com/coast-team/mute)) development. The demo version is available on: <https://coedit.re>.\n\n[websocket]: https://developer.mozilla.org/en/docs/Web/API/WebSocket\n[rtcdatachannel]: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel\n[string]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String\n[uint8array]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n[sigver]: https://github.com/coast-team/sigver\n[logo]: manual/asset/logo_760px.png\n[netflux_example]: manual/asset/example.png\n",
    "longname": "/home/philippe/workspace/netflux/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualAsset",
    "longname": "/home/philippe/workspace/netflux/manual/asset",
    "name": "./manual/asset",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\n## NPM\n\n```shell\nnpm install -S netflux\n```\n\nNetflux has an optional peer dependency: `wrtc`. This package provides WebRTC API in NodeJS, but for now it is not in use as more tests needed. Checkout [wrtc repository](https://github.com/js-platform/node-webrtc) for more info on it.\n\n## What you need\n\nSignaling server is the only mandatory server for Netflux, but for a fully functional peer to peer network which suits all use cases you also need STUN and TURN servers.\n\n> Netflux comes with Signaling and STUN servers by default for easier quickstart.\n\n### Signaling server\n\n> **Default**: `wss://signaling.netflux.coedit.re`\n\nThe only signaling mechanism which is supported by Netflux for now is [Sigver](https://github.com/coast-team/sigver) (NodeJS WebSocket server developed by us).\n\n> **TIP**: Your own instance of Sigver for production is recommended.\n\n### STUN server\n\n**Default**: `stun:stun3.l.google.com:19302`\n\nThere are many other free STUN servers available in the Web.\n\n### TURN server\n\nThere are no free TURN servers available in the Web. Two solutions exist:\n\n- Rent one. Checkout [Xirsys](https://xirsys.com/) for example.\n- Deploy your own instance. The paragraphe below provides a guide on how to deploy and configure [`coturn`](https://github.com/coturn/coturn) open source TURN server. Also checkout [_Choosing a TURN server_](https://rtcquickstart.org/guide/multi/turn-server-choice.html) for a list of open source TURN servers.\n\n## How to deploy STUN/TURN servers\n\nThis guide present a basic configuration for [coturn](https://github.com/coturn/coturn).\nIt allow us to deploy our own STUN/TURN server in order to connect users behind a NAT or Firewall.\n\nFor more informations or options, see coturn [documentation](https://github.com/coturn/coturn/wiki/README).\n\nOn most Linux Distribution, the package is in the repo:\n`apt-get install coturn`\n\nYou must have SQLite installed:\n`sudo apt-get install sqlite3 libsqlite3-dev`\n\nConfig file can be found at:\n`/etc/turnserver.conf`\n\nSimple config file should look like this:\n\n```bash\n# you can listen ports 3478 and 5349 instead of 80/443\nlistening-port=80\ntls-listening-port=443\n\nlistening-ip=YOUR_IP_ADDRESS\nrelay-ip=YOUR_IP_ADDRESS\n\nrealm=YOUR_DOMAIND.COM\nserver-name=OUR_DOMAIND.COM\n\nfingerprint\n\n# webRTC authentication method\nlt-cred-mech\n\n# WebRTC credentials\nuser=YOUR_USER_NAME:YOUR_PASSWORD\n\n# Quota\ntotal-quota=100\nbps-capacity=0\nstable-nonce\n\n# Add ssl certificate for your server\ncert=/etc/ssl/certificate.pem\npkey=/etc/ssl/private.key\ncipher-list=\"ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:!DH+AES:!ECDH+3DES:!DH+3DES:!RSA+AES:!RSA+3DES:!ADH:!AECDH:!MD5\"\nno-loopback-peers\nno-multicast-peers\nno-stdout-log\n```\n\nIf you don't have any SSL certificate, you may use [Let's Encrypt](https://letsencrypt.org/).\n\nLaunch server:\n\n```turnserver`\n\nor in daemon:\n\n`turnserver -o`\n\nVerify that the server is up and running with [Trickle ICE](https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/usage.md",
    "name": "./manual/usage.md",
    "content": "# Usage\n\nThere are 4 builds (all ES5 code):\n\n- `dist/netflux.cjs.js` CommonJS format for NodeJS.\n- `dist/esm/netflux.node.js` ECMAScript 6 module format for NodeJS.\n- `dist/esm/netflux.browser.js` ECMAScript 6 module format for browsers.\n- `dist/netflux.umd.js` UMD format for browsers.\n\nThe `package.json` contains the following fields:\n\n```json\n...\n\"main\": \"dist/netflux.cjs.js\",\n\"module\": \"dist/esm/index.node.js\",\n\"browser\": \"dist/esm/index.browser.js\",\n...\n```\n\nAll builds are either for NodeJS or for Browser environment.\n\n**For browser environment** exported members are:\n\n- `WebGroup` class\n- `WebGroupState` enum\n- `SignalingState` enum\n- `Topology` enum\n- `DataType` type\n- `WebGroupOption` type\n\n**For NodeJS environment** exported members are the same as for browser plus:\n\n- `Bot` class\n- `BotOptions` type.\n\n## CommonJS\n\n`dist/netflux.cjs.js` - CommonJS format, built for NodeJS.\n\n```Javascript\n// NodeJS\nconst netflux = require('netflux')\nvar wg = new netflux.WebGroup()\n```\n\n## ES module\n\n`esm/index.node.js` and `esm/index.browser.js` are suitable for Webpack, Browserify or any alike, which also undersands `package.json#module` and `package.json#module` properties respectively and can parse ES modules.\n\n`esm/index.node.js` is build for NodeJS: contains all exported API members and all necessary polyfills for NodeJS environment.\n\n`esm/index.browser.js` is build for browsers.\n\n```javascript\nexport { WebGroup, WebGroupState, Bot, BotOptions } from 'netflux'\nconst wg = new WebGroup()\n```\n\n## UMD\n\n`dist/netflux.umd.js` - Universal Module Definition format is compatible with AMD, CommonJS and \"global\" modules. Built for browser and suitable for Webpack, Browserify and any other who also understands `package.json#browser` property.\n\n```html\n<!-- Browser global usage example -->\n<script src=\"netflux.es5.umd.js\">\n  window.netflux !== undefined // true\n  var wg = new window.netflux.WebGroup()\n</script>\n```\n\n## Configuration\n\nFor a `WebGroup` object all options are optional.\n\n```javascript\n// Example:\nconst wg = new WebGroup({\n  signalingServer: 'MY_SIGNALING_URL',\n  rtcConfiguration: {\n    iceServers: [\n      { urls: 'stun:mystun.org' },\n      {\n        urls: ['turn:myturn.org?transport=udp', 'turn:myturn.org?transport=tcp'],\n        username: 'user',\n        password: 'password',\n      },\n    ],\n  },\n})\n```\n\nFor `Bot` the server option is mandatory.\n\n```javascript\n// Example:\nconst http = require('http')\nconst myServer = http.createServer()\nconst wg = new Bot({\n  server: myServer,\n  signalingServer: 'MY_SIGNALING_URL',\n  webGroupOptions: {\n    rtcConfiguration: {\n      iceServers: [\n        { urls: 'stun:mystun.org' },\n        {\n          urls: ['turn:myturn.org?transport=udp', 'turn:myturn.org?transport=tcp'],\n          username: 'user',\n          password: 'password',\n        },\n      ],\n    },\n  },\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/knownobstacles.md",
    "name": "./manual/knownobstacles.md",
    "content": "# Known WebRTC obstacles\n\nConnection establishment over WebRTC may ancounter different obstacles like NAT, Firewall, port blocking. But besides network obstacles there is also browser configuration that may prevent from connection creation.\n\n## Firefox extensions\n\nSome extensions for Firefox (Privacy Badger for instance) modify WebRTC configuration in browser. Checkout `about:config` and look for `peerconnection.ice`. If the _Status_ column is _default_ then the parameter was not modified.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/faq.md",
    "name": "./manual/faq.md",
    "content": "# FAQ\n\n## How Netflux chooses between `RTCDataChannel` and `WebSocket`\n\nNetflux operates with `RTCDataChannel` (WebRTC) and `WebSocket` connection technologies.\n\nTechnically `RTCDataChannel` may be established between:\n\n- Browser and Browser.\n- Browser and Server.\n- Server and Server.\n\nOn the other hand, a `WebSocket` may be created only between:\n\n- Browser and Server.\n- Server and Server.\n\nBut in practice:\n\n- All modern browsers support `WebSocket` (Chrome, Firefox, Edge, Safary etc.), but only some of them support `RTCDataChannel` (Chrome, Firefox, Safari soon and Edge one day maybe).\n- Servers may or may not listen on `WebSocket` or connect over `WebSocket` and may or may not support `RTCDataChannel`.\n\nThis technical diversity pushes us to try all possibilities in order to create a connection between two peers based on their capabilities.\n\nBetween two peers, there is always one who initiates the connection, while the other is in a passive state. Lets say peer _A_ wants to connect to peer _B_ (i.e. _A_ is the initiator).\n\nThe following algorithm is the same for _A_ and _B_ and is executed each time a `message` is received. It runs through all possiblities in order to establish a connection between these peers (i.e. `return SUCCESS` if the connection succeed and `return FAILED` otherwise). It is important that the initiator peer (i.e. A) must be notified about the algorithm's result, while for the second peer (who is in the passive state) this information has no importance.\n\n`message` variable below persistes the state of the actions for both peers. It is updated by both and is exchanged between them.\n\n```pseudocode\n// Pseudocode:\n// I received a `message` from another peer\n\nif anotherPeerIsListeningOnWebSocketAndIHaveNotTriedToConnectYet(message)\n  if WebSocket connection succeed\n    return SUCCESS\n  else\n    update(message)\n\nif iAmListeningOnWebSocketAndAnotherPeerHasNotTriedToConnectYet(message)\n  send(message)\n  return\n\nif bothPeersSupportRTCDataChannel(message)\n  if iHaveNotTriedToConnectYet(message)\n    if RTCDataChannel connection succeed\n      return SUCCESS\n    else\n      update(message)\n  if anotherPeerHasNotTriedToConnectYet(message)\n    send(message)\n    return\n\nif iAmTheInitiator(message)\n  return FAILED\nelse\n  send(message)\n```\n\n## State description\n\nThis section describes what trigger the `WebChannel` (i.e. `WebGroup`) state to change.\n\nPossible values for `WebChannel`, `Signaling` and `Topology` states are:\n\n| WebChannel | description                                                                                                                                        |\n| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `JOINING`  | You are about to join the group.                                                                                                                   |\n| `JOINED`   | You have successfully joined the group.                                                                                                            |  |\n| `LEFT`     | You have successfully left the group or couldn't join. This is also the initial value (i.e. after `new WebChannel()` and before calling `join()`). |\n\n| Signaling state | description                                                                                                                                                                                                                                                                                           |\n| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `CONNECTING`    | The connection with Signaling server is not yet open (equivalent to `WebSocket.CONNECTING`).                                                                                                                                                                                                          |\n| `OPEN`          | The connection with Signaling server is open (equivalent to `WebSocket.OPEN`).                                                                                                                                                                                                                        |\n| `CHECKING`      | Signaling server is about to vefiry that you are connected to at least one group member. If so, then the state becomes `CHECKED` and nothing to do, otherwise it prompt you to connect to the group member. After that the state becomes `CHECKED` and the `TopologyService` should rejoin the group. |\n| `CHECKED`       | You are connected to at least one group member or you are the only group member.                                                                                                                                                                                                                      |  |\n| `CLOSED`        | The connection with Signaling server is closed or couldn't be opened (equivalent to `WebSocket.CLOSED`).                                                                                                                                                                                              |\n\n| Topology state | description                                                                                                                                                                                                                                |\n| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `CONSTRUCTING` | Thanks to the Signaling server you are connected to one of the group member. From now the topology service is about to create the rest of connections, if necessary, in order to keep the topology structure and assure messages delivery. |\n| `CONSTRUCTED`  | The topology is considerated as constructed.                                                                                                                                                                                               |\n| `IDLE`         | All connections with group members were closed or topology failed to construct the peer to peer network.                                                                                                                                   |\n\n### Events\n\n#### Member left event\n\n| Singaling | Topology    | adjacent member | not only you left in the group | Result          |\n| --------- | ----------- | --------------- | ------------------------------ | --------------- |\n| CHECKED   | CONSTRUCTED | true            | true                           | $signalingCheck |\n\n#### Signaling state event\n\n| Singaling | Topology      | connected | rejoinEnabled | Result               |\n| --------- | ------------- | --------- | ------------- | -------------------- |\n| CLOSED    | IDLE          |           | true          | $rejoin              |\n| CLOSED    | IDLE          |           | false         | $leave               |\n| CLOSED    | CONSTRUCTED   |           | true          | $connectToSignaling  |\n| OPEN      | !CONSTRUCTING |           |               | $signalingCheck      |\n| CHECKED   | IDLE          | true      |               | Topology.CONSTRUCTED |\n| CHECKED   | CONSTRUCTED   |           |               | WebChannel.JOINED    |\n\n#### Topology state event\n\n| Topology     | Singaling  | rejoinEnabled | Result                               |\n| ------------ | ---------- | ------------- | ------------------------------------ |\n| CONSTRUCTING |            |               | WebChannel.JOINING                   |\n| CONSTRUCTED  | OPEN       |               | $signalingCheck                      |\n| CONSTRUCTED  | CHECKED    |               | WebChannel.JOINED & $signalingCheck  |\n| CONSTRUCTED  | CLOSED     |               | $connectToSignaling                  |\n| IDLE         | CLOSED     | true          | $rejoin                              |\n| IDLE         | CLOSED     | false         | $leave                               |\n| IDLE         | CONNECTING |               | WebChannel.JOINING                   |\n| IDLE         | OPEN       |               | WebChannel.JOINING & $signalingCheck |\n| IDLE         | CHECKING   |               | WebChannel.JOINING                   |\n| IDLE         | CHECKED    |               | $signalingCheck                      |\n\n#### Join method call\n\n| WebChannel | onLine | Visibility | Result |\n| ---------- | ------ | ---------- | ------ |\n| LEFT       | true   | visible    | $join  |\n\n#### Leave method call\n\n| WebChannel | Result |\n| ---------- | ------ |\n| !LEFT      | $leave |\n\n#### onLine() event (online/offline events, navigator.onLine)\n\n| WebChannel | Visibility | rejoinEnabled | Result           |\n| ---------- | ---------- | ------------- | ---------------- |\n| LEFT       | visible    | true          | $leave.1 & $join |\n\n#### isVisible() event (Page Visibility API)\n\n| WebChannel | onLine | rejoinEnabled | Result           |\n| ---------- | ------ | ------------- | ---------------- |\n| LEFT       | true   | true          | $leave.1 & $join |\n\n> $join -> consists of three steps:\n\n1.  Initialize WebChannel properties (ids, members etc.), then\n2.  Set WebChannel state to JOINING and finally\n3.  Connect to Signaling server\n\n> $leave -> consists of two steps\n\n1.  Clean WebChannel properties (ids, members, clean servicies) as if we were doing `new WebChannel()`, then\n2.  Set WebChannel state to LEFT\n\n> $rejoin -> consists of executing the following algorithm:\n\n```pseudocode\n  Execute $leave.1\n    Execute $join.1\n    Execute $join.2\n    setTimeout\n      if (WebChannel.LEFT && visible && onLine && rejoinEnabled) then\n        $connectToSignaling\n```\n\n> $connectToSignaling -> the third step of the $join process\n>\n> $signalingCheck -> check with Signaling if still connected with the rest of the group\n",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 63,
    "kind": "testFile",
    "name": "test/functional/1-bot.test.js",
    "content": "/// <reference types='jasmine' />\nimport { SignalingState, Topology, WebGroupState } from '../../src/index.browser';\nimport { botGetData, botJoin, botLeave, botWaitJoin, randomKey, SIGNALING_URL, } from '../util/helper';\n/** @test {WebGroup} */\ndescribe(' - 1 bot', () => {\n    /** @test {WebGroup#join} */\n    describe('join', () => {\n        let key;\n        beforeEach((done) => {\n            key = randomKey();\n            botJoin(key).then(() => done());\n        });\n        afterEach((done) => {\n            botLeave(key).then(() => done());\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            const expected = [\n                SignalingState.CONNECTING,\n                SignalingState.OPEN,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n            ];\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.onSignalingStateCalled).toEqual(expected.length);\n                expect(data.signalingStates).toEqual(expected);\n                expect(data.signalingState).toEqual(SignalingState.CHECKED);\n                done();\n            });\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            const expected = [WebGroupState.JOINING, WebGroupState.JOINED];\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.state).toEqual(WebGroupState.JOINED);\n                expect(data.states).toEqual(expected);\n                expect(data.onStateCalled).toEqual(expected.length);\n                done();\n            });\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should NOT be notified about new member', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.onMemberJoinCalled).toEqual(0);\n                expect(data.joinedMembers.length).toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.onMemberLeaveCalled).toEqual(0);\n                expect(data.leftMembers.length).toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.onMessageToBeCalled).toEqual(0);\n                expect(data.messages).toEqual([]);\n                done();\n            });\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.autoRejoin).toBeFalsy();\n                done();\n            });\n        });\n        /** @test {WebGroup#signalinServer} */\n        it('signalinServer should not change', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.signalingServer).toEqual(SIGNALING_URL);\n                done();\n            });\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.topology).toEqual(Topology.FULL_MESH);\n                done();\n            });\n        });\n        /** @test {WebGroup#members} */\n        it('should have only me as a member', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.members).toEqual([data.myId]);\n                done();\n            });\n        });\n        /** @test {WebGroup#myId} */\n        it('my id should not be 0', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.myId).not.toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should not be 0', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.id).not.toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#key} */\n        it('key should be the one provided to the join method', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.key).toEqual(key);\n                done();\n            });\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be JOINED', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.state).toEqual(WebGroupState.JOINED);\n                done();\n            });\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CHECKED', (done) => {\n            botWaitJoin(key)\n                .then(() => botGetData(key))\n                .then((data) => {\n                expect(data.signalingState).toEqual(SignalingState.CHECKED);\n                done();\n            });\n        });\n    });\n    /** @test {WebGroup#leave} */\n    describe('leave', () => {\n        let key;\n        beforeEach((done) => {\n            key = randomKey();\n            botJoin(key).then(() => done());\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            const expected = [WebGroupState.JOINING, WebGroupState.JOINED, WebGroupState.LEFT];\n            botLeave(key).then((data) => {\n                expect(data.states).toEqual(expected);\n                expect(data.onStateCalled).toEqual(expected.length);\n                done();\n            });\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            const expected = [\n                SignalingState.CONNECTING,\n                SignalingState.OPEN,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CLOSED,\n            ];\n            botLeave(key).then((data) => {\n                expect(data.signalingStates).toEqual(expected);\n                expect(data.onSignalingStateCalled).toEqual(expected.length);\n                done();\n            });\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should NOT be notified about new member', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.onMemberJoinCalled).toEqual(0);\n                expect(data.joinedMembers.length).toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.onMemberLeaveCalled).toEqual(0);\n                expect(data.leftMembers.length).toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.onMessageToBeCalled).toEqual(0);\n                expect(data.messages).toEqual([]);\n                done();\n            });\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.autoRejoin).toBeFalsy();\n                done();\n            });\n        });\n        /** @test {WebGroup#signalinServer} */\n        it('signalinServer should not change', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.signalingServer).toEqual(SIGNALING_URL);\n                done();\n            });\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.topology).toEqual(Topology.FULL_MESH);\n                done();\n            });\n        });\n        /** @test {WebGroup#members} */\n        it('should have no members', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.members).toEqual([]);\n                done();\n            });\n        });\n        /** @test {WebGroup#myId} */\n        it('my id should be 0', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.myId).toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should be 0', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.id).toEqual(0);\n                done();\n            });\n        });\n        /** @test {WebGroup#key} */\n        it('key should be empty', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.key).toEqual('');\n                done();\n            });\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be LEFT', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.state).toEqual(WebGroupState.LEFT);\n                done();\n            });\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CLOSED', (done) => {\n            botLeave(key).then((data) => {\n                expect(data.signalingState).toEqual(SignalingState.CLOSED);\n                done();\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/1-bot.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/functional/1-bot.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0",
    "access": null,
    "description": " - 1 bot",
    "lineNumber": 5,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 65,
    "kind": "test",
    "name": "describe1",
    "testId": 1,
    "memberof": "test/functional/1-bot.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1",
    "access": null,
    "description": "join",
    "lineNumber": 7,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 66,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it2",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 17,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 67,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it3",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 36,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 68,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it4",
    "access": null,
    "description": "should NOT be notified about new member",
    "lineNumber": 48,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 69,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it5",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 58,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 70,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it6",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 68,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 71,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it7",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 78,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 72,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it8",
    "access": null,
    "description": "signalinServer should not change",
    "lineNumber": 87,
    "testTargets": [
      "WebGroup#signalinServer"
    ]
  },
  {
    "__docId__": 73,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it9",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 96,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 74,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it10",
    "access": null,
    "description": "should have only me as a member",
    "lineNumber": 105,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 75,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it11",
    "access": null,
    "description": "my id should not be 0",
    "lineNumber": 114,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 76,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it12",
    "access": null,
    "description": "WebGroup id should not be 0",
    "lineNumber": 123,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 77,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it13",
    "access": null,
    "description": "key should be the one provided to the join method",
    "lineNumber": 132,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 78,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it14",
    "access": null,
    "description": "WebGroup state should be JOINED",
    "lineNumber": 141,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 79,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/functional/1-bot.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe1.it15",
    "access": null,
    "description": "Signaling state should be CHECKED",
    "lineNumber": 150,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 80,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "test/functional/1-bot.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16",
    "access": null,
    "description": "leave",
    "lineNumber": 160,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 81,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it17",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 167,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 82,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it18",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 176,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 83,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it19",
    "access": null,
    "description": "should NOT be notified about new member",
    "lineNumber": 193,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 84,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it20",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 201,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 85,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it21",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 209,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 86,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it22",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 217,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 87,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it23",
    "access": null,
    "description": "signalinServer should not change",
    "lineNumber": 224,
    "testTargets": [
      "WebGroup#signalinServer"
    ]
  },
  {
    "__docId__": 88,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it24",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 231,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 89,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it25",
    "access": null,
    "description": "should have no members",
    "lineNumber": 238,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 90,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it26",
    "access": null,
    "description": "my id should be 0",
    "lineNumber": 245,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 91,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it27",
    "access": null,
    "description": "WebGroup id should be 0",
    "lineNumber": 252,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 92,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it28",
    "access": null,
    "description": "key should be empty",
    "lineNumber": 259,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 93,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it29",
    "access": null,
    "description": "WebGroup state should be LEFT",
    "lineNumber": 266,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 94,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/functional/1-bot.test.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-bot.test.js~describe0.describe16.it30",
    "access": null,
    "description": "Signaling state should be CLOSED",
    "lineNumber": 273,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 95,
    "kind": "testFile",
    "name": "test/functional/1-client.test.js",
    "content": "/// <reference types='jasmine' />\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { cleanWebGroup, SIGNALING_URL, wait } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe(' - 1 client', () => {\n    let wg1;\n    /** @test {WebGroup#constructor} */\n    it('constructor', () => {\n        const wg = new WebGroup({ signalingServer: SIGNALING_URL });\n        // Check members\n        const id = Reflect.getOwnPropertyDescriptor(wg, 'id');\n        expect(id).toBeDefined();\n        expect(wg.id).toBe(0);\n        expect(id.set).toBeUndefined();\n        const myId = Reflect.getOwnPropertyDescriptor(wg, 'myId');\n        expect(myId).toBeDefined();\n        expect(wg.myId).toBe(0);\n        expect(myId.set).toBeUndefined();\n        const key = Reflect.getOwnPropertyDescriptor(wg, 'key');\n        expect(key).toBeDefined();\n        expect(wg.key).toBe('');\n        expect(key.set).toBeUndefined();\n        const members = Reflect.getOwnPropertyDescriptor(wg, 'members');\n        expect(members).toBeDefined();\n        expect(wg.members).toEqual([]);\n        expect(members.set).toBeUndefined();\n        const neighbors = Reflect.getOwnPropertyDescriptor(wg, 'neighbors');\n        expect(neighbors).toBeDefined();\n        expect(wg.neighbors).toEqual([]);\n        expect(neighbors.set).toBeUndefined();\n        const topology = Reflect.getOwnPropertyDescriptor(wg, 'topology');\n        expect(topology).toBeDefined();\n        expect(wg.topology).toBe(Topology.FULL_MESH);\n        expect(topology.set).toBeUndefined();\n        const state = Reflect.getOwnPropertyDescriptor(wg, 'state');\n        expect(state).toBeDefined();\n        expect(wg.state).toBe(WebGroupState.LEFT);\n        expect(state.set).toBeUndefined();\n        const signalingState = Reflect.getOwnPropertyDescriptor(wg, 'signalingState');\n        expect(signalingState).toBeDefined();\n        expect(wg.signalingState).toBe(SignalingState.CLOSED);\n        expect(signalingState.set).toBeUndefined();\n        const signalingServer = Reflect.getOwnPropertyDescriptor(wg, 'signalingServer');\n        expect(signalingServer).toBeDefined();\n        expect(wg.signalingServer).toBe(SIGNALING_URL);\n        expect(signalingServer.set).toBeUndefined();\n        expect(wg.autoRejoin).toBeTruthy();\n        wg.autoRejoin = false;\n        expect(wg.autoRejoin).toBeFalsy();\n        // Check event handlers\n        expect(wg.onMemberJoin).toBeUndefined();\n        expect(wg.onMemberLeave).toBeUndefined();\n        expect(wg.onMessage).toBeUndefined();\n        expect(wg.onStateChange).toBeUndefined();\n        expect(wg.onSignalingStateChange).toBeUndefined();\n        // Check methods\n        expect(typeof wg.join).toBe('function');\n        expect(typeof wg.invite).toBe('function');\n        expect(typeof wg.leave).toBe('function');\n        expect(typeof wg.send).toBe('function');\n        expect(typeof wg.sendTo).toBe('function');\n    });\n    /** @test {WebGroup#join} */\n    describe('join', () => {\n        beforeEach(() => {\n            wg1 = new WebGroup(WebGroupOptions);\n        });\n        afterEach(() => {\n            cleanWebGroup(wg1);\n            wg1.leave();\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            let called = 0;\n            const states = [];\n            const expected = [\n                SignalingState.CONNECTING,\n                SignalingState.OPEN,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n            ];\n            wg1.onSignalingStateChange = (state) => {\n                called++;\n                states.push(state);\n                if (called === expected.length) {\n                    wait(1000).then(() => {\n                        expect(states).toEqual(expected);\n                        expect(called).toEqual(expected.length);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CHECKED', (done) => {\n            let called = 0;\n            wg1.onSignalingStateChange = (state) => {\n                called++;\n                if (called === 6) {\n                    wait(1000).then(() => {\n                        expect(wg1.signalingState).toEqual(SignalingState.CHECKED);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            let called = 0;\n            const states = [];\n            const expected = [WebGroupState.JOINING, WebGroupState.JOINED];\n            wg1.onStateChange = (state) => {\n                called++;\n                states.push(state);\n                if (called === expected.length) {\n                    wait(1000).then(() => {\n                        expect(states).toEqual(expected);\n                        expect(called).toEqual(expected.length);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be JOINED', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(wg1.state).toEqual(WebGroupState.JOINED);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should NOT be notified about new member', (done) => {\n            let called1 = 0;\n            wg1.onMemberJoin = () => called1++;\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            let called1 = 0;\n            wg1.onMemberLeave = () => called1++;\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            let called1 = 0;\n            wg1.onMessage = () => called1++;\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#members} */\n        it('should have only me as a member', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.members).toEqual([wg1.myId]);\n                    wait(1000).then(() => {\n                        expect(wg1.members).toEqual([wg1.myId]);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#myId} */\n        it('my id should not be 0', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.myId).not.toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.myId).not.toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should not be 0', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.id).not.toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.id).not.toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#key} */\n        it('key should not be empty', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.key).not.toEqual('');\n                    wait(1000).then(() => {\n                        expect(wg1.key).not.toEqual('');\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                    wait(1000).then(() => {\n                        expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#signalingServer} */\n        it('Signaling server should not change', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                    wait(1000).then(() => {\n                        expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.autoRejoin).toBeFalsy();\n                    wait(1000).then(() => {\n                        expect(wg1.autoRejoin).toBeFalsy();\n                        done();\n                    });\n                }\n            };\n            wg1.join();\n        });\n        /** @test {WebGroup#join} */\n        it('should join with a specified key', (done) => {\n            const key = 'ArtIsLongLifeIsShort';\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.key).toEqual(key);\n                    done();\n                }\n            };\n            wg1.join(key);\n        });\n    });\n    /** @test {WebGroup#leave} */\n    describe('leave', () => {\n        beforeEach((done) => {\n            wg1 = new WebGroup(WebGroupOptions);\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    cleanWebGroup(wg1);\n                    done();\n                }\n            };\n            wg1.join();\n        });\n        afterEach(() => cleanWebGroup(wg1));\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            let called1 = 0;\n            const states = [];\n            const expected = [WebGroupState.LEFT];\n            wg1.onStateChange = (state) => {\n                states.push(state);\n                called1++;\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(expected.length);\n                        expect(states).toEqual(expected);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            let called1 = 0;\n            const states = [];\n            const expected = [SignalingState.CLOSED];\n            wg1.onSignalingStateChange = (state) => {\n                states.push(state);\n                called1++;\n                wait(1000).then(() => {\n                    expect(called1).toEqual(expected.length);\n                    expect(states).toEqual(expected);\n                    done();\n                });\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CLOSED', (done) => {\n            let called = 0;\n            wg1.onSignalingStateChange = (state) => {\n                called++;\n                if (state === SignalingState.CLOSED) {\n                    wait(1000).then(() => {\n                        expect(called).toEqual(1);\n                        expect(wg1.signalingState).toEqual(SignalingState.CLOSED);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be LEFT', (done) => {\n            let called = 0;\n            wg1.onStateChange = (state) => {\n                called++;\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called).toEqual(1);\n                        expect(wg1.state).toEqual(WebGroupState.LEFT);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should NOT be notified about new member', (done) => {\n            let called1 = 0;\n            wg1.onMemberJoin = () => called1++;\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            let called1 = 0;\n            wg1.onMemberLeave = () => called1++;\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            let called1 = 0;\n            wg1.onMessage = () => called1++;\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#members} */\n        it('should have no members', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.members).toEqual([]);\n                    wait(1000).then(() => {\n                        expect(wg1.members).toEqual([]);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#myId} */\n        it('my id should be 0', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.myId).toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.myId).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should be 0', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.id).toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.id).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#key} */\n        it('key should be empty', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.key).toEqual('');\n                    wait(1000).then(() => {\n                        expect(wg1.key).toEqual('');\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                    wait(1000).then(() => {\n                        expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#signalingServer} */\n        it('Signaling server should not change', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                    wait(1000).then(() => {\n                        expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.autoRejoin).toBeFalsy();\n                    wait(1000).then(() => {\n                        expect(wg1.autoRejoin).toBeFalsy();\n                        done();\n                    });\n                }\n            };\n            wg1.leave();\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/1-client.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 96,
    "kind": "test",
    "name": "describe31",
    "testId": 31,
    "memberof": "test/functional/1-client.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31",
    "access": null,
    "description": " - 1 client",
    "lineNumber": 9,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 97,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "test/functional/1-client.test.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.it32",
    "access": null,
    "description": "constructor",
    "lineNumber": 12,
    "testTargets": [
      "WebGroup#constructor"
    ]
  },
  {
    "__docId__": 98,
    "kind": "test",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/functional/1-client.test.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33",
    "access": null,
    "description": "join",
    "lineNumber": 68,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 99,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it34",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 77,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 100,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it35",
    "access": null,
    "description": "Signaling state should be CHECKED",
    "lineNumber": 102,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 101,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it36",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 116,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 102,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it37",
    "access": null,
    "description": "WebGroup state should be JOINED",
    "lineNumber": 134,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 103,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it38",
    "access": null,
    "description": "should NOT be notified about new member",
    "lineNumber": 146,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 104,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it39",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 160,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 105,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it40",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 174,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 106,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it41",
    "access": null,
    "description": "should have only me as a member",
    "lineNumber": 188,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 107,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it42",
    "access": null,
    "description": "my id should not be 0",
    "lineNumber": 201,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 108,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it43",
    "access": null,
    "description": "WebGroup id should not be 0",
    "lineNumber": 214,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 109,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it44",
    "access": null,
    "description": "key should not be empty",
    "lineNumber": 227,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 110,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it45",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 240,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 111,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it46",
    "access": null,
    "description": "Signaling server should not change",
    "lineNumber": 253,
    "testTargets": [
      "WebGroup#signalingServer"
    ]
  },
  {
    "__docId__": 112,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it47",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 266,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 113,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "test/functional/1-client.test.js~describe31.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe33.it48",
    "access": null,
    "description": "should join with a specified key",
    "lineNumber": 279,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 114,
    "kind": "test",
    "name": "describe49",
    "testId": 49,
    "memberof": "test/functional/1-client.test.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49",
    "access": null,
    "description": "leave",
    "lineNumber": 291,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 115,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it50",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 304,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 116,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it51",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 322,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 117,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it52",
    "access": null,
    "description": "Signaling state should be CLOSED",
    "lineNumber": 338,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 118,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it53",
    "access": null,
    "description": "WebGroup state should be LEFT",
    "lineNumber": 353,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 119,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it54",
    "access": null,
    "description": "should NOT be notified about new member",
    "lineNumber": 368,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 120,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it55",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 382,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 121,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it56",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 396,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 122,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it57",
    "access": null,
    "description": "should have no members",
    "lineNumber": 410,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 123,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it58",
    "access": null,
    "description": "my id should be 0",
    "lineNumber": 423,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 124,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it59",
    "access": null,
    "description": "WebGroup id should be 0",
    "lineNumber": 436,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 125,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it60",
    "access": null,
    "description": "key should be empty",
    "lineNumber": 449,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 126,
    "kind": "test",
    "name": "it61",
    "testId": 61,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it61",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 462,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 127,
    "kind": "test",
    "name": "it62",
    "testId": 62,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it62",
    "access": null,
    "description": "Signaling server should not change",
    "lineNumber": 475,
    "testTargets": [
      "WebGroup#signalingServer"
    ]
  },
  {
    "__docId__": 128,
    "kind": "test",
    "name": "it63",
    "testId": 63,
    "memberof": "test/functional/1-client.test.js~describe31.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1-client.test.js~describe31.describe49.it63",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 488,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 129,
    "kind": "testFile",
    "name": "test/functional/2-bot_client.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, Topology, WebGroup } from '../../src/index.browser';\nimport { WebGroupState } from '../../src/index.browser';\nimport { areTheSame, botGetData, botJoin, botLeave, cleanWebGroup, randomKey, SIGNALING_URL, wait, } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('  - 2 members: bot first, then client', () => {\n    let called;\n    let key;\n    let client;\n    beforeEach(() => {\n        called = 0;\n        key = randomKey();\n        client = new WebGroup(WebGroupOptions);\n    });\n    /** @test {WebGroup#join} */\n    describe('join', () => {\n        beforeEach((done) => botJoin(key).then(() => done()));\n        afterEach((done) => {\n            cleanWebGroup(client);\n            client.leave();\n            botLeave(key).then(() => done());\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            const states = [];\n            const expected = [\n                SignalingState.CONNECTING,\n                SignalingState.OPEN,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n            ];\n            client.onSignalingStateChange = (state) => {\n                states.push(state);\n                called++;\n                if (called === expected.length) {\n                    expect(states).toEqual(expected);\n                    botGetData(key).then((bot) => {\n                        expect(bot.signalingState).toEqual(SignalingState.CHECKED);\n                        expect(called).toEqual(expected.length);\n                        expect(states).toEqual(expected);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CHECKED', (done) => {\n            client.onSignalingStateChange = (state) => {\n                called++;\n                if (called === 6) {\n                    botGetData(key).then((bot) => {\n                        expect(bot.signalingState).toEqual(SignalingState.CHECKED);\n                        expect(client.signalingState).toEqual(SignalingState.CHECKED);\n                        expect(called).toEqual(6);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            const states = [];\n            const expected = [WebGroupState.JOINING, WebGroupState.JOINED];\n            client.onStateChange = (state) => {\n                states.push(state);\n                called++;\n                if (called === expected.length) {\n                    expect(states).toEqual(expected);\n                    botGetData(key).then((bot) => {\n                        expect(bot.state).toEqual(WebGroupState.JOINED);\n                        expect(called).toEqual(expected.length);\n                        expect(states).toEqual(expected);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be JOINED', (done) => {\n            client.onStateChange = (state) => {\n                called++;\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(bot.state).toEqual(WebGroupState.JOINED);\n                        expect(client.state).toEqual(WebGroupState.JOINED);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should be notified about new member', (done) => {\n            const joinedMembers = [];\n            client.onMemberJoin = (id) => {\n                joinedMembers.push(id);\n                botGetData(key).then((bot) => {\n                    expect(joinedMembers).toEqual([bot.myId]);\n                    expect(bot.joinedMembers).toEqual([client.myId]);\n                    done();\n                });\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            const leftMembers = [];\n            client.onMemberLeave = (id) => leftMembers.push(id);\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(leftMembers).toEqual([]);\n                        expect(bot.leftMembers).toEqual([]);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            client.onMessage = (id) => called++;\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(called).toEqual(0);\n                        expect(bot.onMessageToBeCalled).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#members} */\n        it('should have 2 members', (done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        const expected = [bot.myId, client.myId];\n                        expect(areTheSame(bot.members, expected)).toBeTruthy();\n                        expect(areTheSame(client.members, expected)).toBeTruthy();\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#myId} */\n        it(\"bot's id should not change and the client's id should not be 0\", (done) => {\n            botGetData(key).then((bot) => {\n                const botMyId = bot.myId;\n                client.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        botGetData(key).then((botAfter) => {\n                            expect(botAfter.myId).toEqual(botMyId);\n                            expect(client.myId).not.toEqual(0);\n                            done();\n                        });\n                    }\n                };\n                client.join(key);\n            });\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should not change, should be the same and not 0', (done) => {\n            botGetData(key).then((bot) => {\n                const botWgId = bot.id;\n                client.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        botGetData(key).then((botAfter) => {\n                            expect(botAfter.id).toEqual(botWgId);\n                            expect(client.id).toEqual(botAfter.id);\n                            expect(client.id).not.toEqual(0);\n                            done();\n                        });\n                    }\n                };\n                client.join(key);\n            });\n        });\n        /** @test {WebGroup#key} */\n        it('key should not change, should be the same and not empty', (done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(client.key).toEqual(key);\n                        expect(bot.key).toEqual(key);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(client.topology).toEqual(Topology.FULL_MESH);\n                        expect(bot.topology).toEqual(Topology.FULL_MESH);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#signalingServer} */\n        it('Signaling server should not change', (done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(client.signalingServer).toEqual(SIGNALING_URL);\n                        expect(bot.signalingServer).toEqual(SIGNALING_URL);\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    botGetData(key).then((bot) => {\n                        expect(client.autoRejoin).toBeFalsy();\n                        expect(bot.autoRejoin).toBeFalsy();\n                        done();\n                    });\n                }\n            };\n            client.join(key);\n        });\n    });\n    describe('should send/receive', () => {\n        beforeEach((done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    cleanWebGroup(client);\n                    wait(500).then(() => done());\n                }\n            };\n            botJoin(key).then(() => client.join(key));\n        });\n        afterEach(() => {\n            cleanWebGroup(client);\n            client.leave();\n        });\n        /** @test {WebGroup#send} */\n        it('broadcast String', (done) => {\n            const msgClient = 'sendArt is long, life is short';\n            const msgBot = 'bot: ' + msgClient;\n            client.onMessage = (id, msg) => {\n                called++;\n                expect(msg).toEqual(msgBot);\n                // Check bot bot\n                wait(1000)\n                    .then(() => botGetData(key))\n                    .then((bot) => {\n                    expect(called).toEqual(1);\n                    expect(id).toEqual(bot.myId);\n                    expect(bot.onMessageToBeCalled).toEqual(1);\n                    expect(bot.messages[0].msg).toEqual(msgClient);\n                    expect(bot.messages[0].id).toEqual(client.myId);\n                    done();\n                })\n                    .catch(fail);\n            };\n            // Start sending message\n            client.send(msgClient);\n        });\n        /** @test {WebGroup#send} */\n        it('broadcast ArrayBuffer', (done) => {\n            const msgClient = new Uint8Array([10, 34, 248, 157, 10, 8, 220]);\n            const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n            // Code for peer 1\n            client.onMessage = (id, msg) => {\n                called++;\n                expect(msg).toEqual(msgBot);\n                // Check bot bot\n                wait(1000)\n                    .then(() => botGetData(client.key))\n                    .then((bot) => {\n                    expect(called).toEqual(1);\n                    expect(id).toEqual(bot.myId);\n                    expect(bot.onMessageToBeCalled).toEqual(1);\n                    expect(bot.messages[0].msg).toEqual(Array.from(msgClient));\n                    expect(bot.messages[0].id).toEqual(client.myId);\n                    done();\n                })\n                    .catch(fail);\n            };\n            // Start sending message\n            client.send(msgClient);\n        });\n        /** @test {WebGroup#sendTo} */\n        it('private String', (done) => {\n            const msgClient = 'Art is long, life is short';\n            const msgBot = 'bot: ' + msgClient;\n            // Code for peer 1\n            client.onMessage = (id, msg) => {\n                called++;\n                expect(msg).toEqual(msgBot);\n                // Check bot bot\n                wait(1000)\n                    .then(() => botGetData(client.key))\n                    .then((bot) => {\n                    expect(called).toEqual(1);\n                    expect(id).toEqual(bot.myId);\n                    expect(bot.onMessageToBeCalled).toEqual(1);\n                    expect(bot.messages[0].msg).toEqual(msgClient);\n                    expect(bot.messages[0].id).toEqual(client.myId);\n                    done();\n                })\n                    .catch(fail);\n            };\n            // Start sending message\n            client.sendTo(client.members[1], msgClient);\n        });\n        /** @test {WebGroup#sendTo} */\n        it('private ArrayBuffer', (done) => {\n            const msgClient = new Uint8Array([45, 34, 248, 157, 10, 8, 220]);\n            const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n            // Code for peer 1\n            client.onMessage = (id, msg) => {\n                called++;\n                expect(msg).toEqual(msgBot);\n                // Check bot bot\n                wait(1000)\n                    .then(() => botGetData(client.key))\n                    .then((bot) => {\n                    expect(called).toEqual(1);\n                    expect(id).toEqual(bot.myId);\n                    expect(bot.onMessageToBeCalled).toEqual(1);\n                    expect(bot.messages[0].msg).toEqual(Array.from(msgClient));\n                    expect(bot.messages[0].id).toEqual(client.myId);\n                    done();\n                })\n                    .catch(fail);\n            };\n            // Start sending message\n            client.sendTo(client.members[1], msgClient);\n        });\n    });\n    describe('leave', () => {\n        beforeEach((done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    cleanWebGroup(client);\n                    wait(500).then(() => done());\n                }\n            };\n            botJoin(key).then(() => client.join(key));\n        });\n        afterEach(() => {\n            cleanWebGroup(client);\n            client.leave();\n        });\n        it('bot should still be connected to the signaling server', (done) => {\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000)\n                        .then(() => botGetData(key))\n                        .then((bot) => {\n                        expect(bot.state).toEqual(WebGroupState.JOINED);\n                        expect(bot.signalingState).not.toEqual(SignalingState.CLOSED);\n                        done();\n                    });\n                }\n            };\n            client.leave();\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/2-bot_client.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 130,
    "kind": "test",
    "name": "describe64",
    "testId": 64,
    "memberof": "test/functional/2-bot_client.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64",
    "access": null,
    "description": "  - 2 members: bot first, then client",
    "lineNumber": 11,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 131,
    "kind": "test",
    "name": "describe65",
    "testId": 65,
    "memberof": "test/functional/2-bot_client.test.js~describe64",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65",
    "access": null,
    "description": "join",
    "lineNumber": 21,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 132,
    "kind": "test",
    "name": "it66",
    "testId": 66,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it66",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 29,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 133,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it67",
    "access": null,
    "description": "Signaling state should be CHECKED",
    "lineNumber": 55,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 134,
    "kind": "test",
    "name": "it68",
    "testId": 68,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it68",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 70,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 135,
    "kind": "test",
    "name": "it69",
    "testId": 69,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it69",
    "access": null,
    "description": "WebGroup state should be JOINED",
    "lineNumber": 89,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 136,
    "kind": "test",
    "name": "it70",
    "testId": 70,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it70",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 103,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 137,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it71",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 116,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 138,
    "kind": "test",
    "name": "it72",
    "testId": 72,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it72",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 131,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 139,
    "kind": "test",
    "name": "it73",
    "testId": 73,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it73",
    "access": null,
    "description": "should have 2 members",
    "lineNumber": 145,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 140,
    "kind": "test",
    "name": "it74",
    "testId": 74,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it74",
    "access": null,
    "description": "bot's id should not change and the client's id should not be 0",
    "lineNumber": 159,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 141,
    "kind": "test",
    "name": "it75",
    "testId": 75,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it75",
    "access": null,
    "description": "WebGroup id should not change, should be the same and not 0",
    "lineNumber": 175,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 142,
    "kind": "test",
    "name": "it76",
    "testId": 76,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it76",
    "access": null,
    "description": "key should not change, should be the same and not empty",
    "lineNumber": 192,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 143,
    "kind": "test",
    "name": "it77",
    "testId": 77,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it77",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 205,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 144,
    "kind": "test",
    "name": "it78",
    "testId": 78,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it78",
    "access": null,
    "description": "Signaling server should not change",
    "lineNumber": 218,
    "testTargets": [
      "WebGroup#signalingServer"
    ]
  },
  {
    "__docId__": 145,
    "kind": "test",
    "name": "it79",
    "testId": 79,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe65",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe65.it79",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 231,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 146,
    "kind": "test",
    "name": "describe80",
    "testId": 80,
    "memberof": "test/functional/2-bot_client.test.js~describe64",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe80",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 244
  },
  {
    "__docId__": 147,
    "kind": "test",
    "name": "it81",
    "testId": 81,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe80",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe80.it81",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 259,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 148,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe80",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe80.it82",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 282,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 149,
    "kind": "test",
    "name": "it83",
    "testId": 83,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe80",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe80.it83",
    "access": null,
    "description": "private String",
    "lineNumber": 306,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 150,
    "kind": "test",
    "name": "it84",
    "testId": 84,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe80",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe80.it84",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 330,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 151,
    "kind": "test",
    "name": "describe85",
    "testId": 85,
    "memberof": "test/functional/2-bot_client.test.js~describe64",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe85",
    "access": null,
    "description": "leave",
    "lineNumber": 354
  },
  {
    "__docId__": 152,
    "kind": "test",
    "name": "it86",
    "testId": 86,
    "memberof": "test/functional/2-bot_client.test.js~describe64.describe85",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-bot_client.test.js~describe64.describe85.it86",
    "access": null,
    "description": "bot should still be connected to the signaling server",
    "lineNumber": 368
  },
  {
    "__docId__": 153,
    "kind": "testFile",
    "name": "test/functional/2-client_bot.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { Topology } from '../../src/index.common.doc';\nimport { areTheSame, BOT_URL, botGetData, botWaitJoin, cleanWebGroup, Queue, SIGNALING_URL, wait, } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('  - 2 members: client invites bot', () => {\n    let client;\n    /** @test {WebGroup#invite} */\n    describe('invite', () => {\n        beforeEach((done) => {\n            client = new WebGroup(WebGroupOptions);\n            client.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    cleanWebGroup(client);\n                    wait(500).then(() => done());\n                }\n            };\n            client.join();\n        });\n        afterEach(() => {\n            cleanWebGroup(client);\n            client.leave();\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            client.invite(BOT_URL);\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(bot.onSignalingStateCalled).toEqual(4);\n                done();\n            });\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CHECKED', (done) => {\n            client.invite(BOT_URL);\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.signalingState).toEqual(SignalingState.CHECKED);\n                expect(bot.signalingState).toEqual(SignalingState.CHECKED);\n                done();\n            });\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state of the bot only', (done) => {\n            let called = 0;\n            client.onStateChange = () => called++;\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(called).toEqual(0);\n                expect(bot.onStateCalled).toEqual(1);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be JOINED for both', (done) => {\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.state).toEqual(WebGroupState.JOINED);\n                expect(bot.state).toEqual(WebGroupState.JOINED);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should be notified about new member', (done) => {\n            let called1 = 0;\n            const clientJoinedMembers = [];\n            client.onMemberJoin = (id) => {\n                clientJoinedMembers.push(id);\n                called1++;\n            };\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(bot.onMemberJoinCalled).toEqual(1);\n                expect(bot.joinedMembers).toEqual([client.myId]);\n                expect(called1).toEqual(1);\n                expect(clientJoinedMembers).toEqual([bot.myId]);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            let called1 = 0;\n            const clientLeftMembers = [];\n            client.onMemberLeave = (id) => {\n                clientLeftMembers.push(id);\n                called1++;\n            };\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(bot.onMemberLeaveCalled).toEqual(0);\n                expect(bot.leftMembers).toEqual([]);\n                expect(called1).toEqual(0);\n                expect(clientLeftMembers).toEqual([]);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            let called1 = 0;\n            client.onMessage = (id) => called1++;\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(bot.onMessageToBeCalled).toEqual(0);\n                expect(called1).toEqual(0);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#members} */\n        it('should have 2 members', (done) => {\n            let _bot;\n            const queue = new Queue(2, () => {\n                wait(1000).then(() => {\n                    const expected = [client.myId, _bot.myId];\n                    expect(areTheSame(client.members, expected)).toBeTruthy();\n                    expect(areTheSame(_bot.members, expected)).toBeTruthy();\n                    done();\n                });\n            });\n            client.onMemberJoin = (id) => {\n                expect(areTheSame(client.members, [client.myId, id])).toBeTruthy();\n                queue.done();\n            };\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                _bot = bot;\n                expect(areTheSame(bot.members, [client.myId, bot.myId])).toBeTruthy();\n                queue.done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#myId} */\n        it(\"client's id should not change and bot's id should not be 0\", (done) => {\n            const clientMyId = client.myId;\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.myId).toEqual(clientMyId);\n                expect(bot.myId).not.toEqual(0);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should not change, should be the same and not 0', (done) => {\n            const wgId = client.id;\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.id).toEqual(wgId);\n                expect(bot.id).toEqual(client.id);\n                expect(bot.id).not.toEqual(0);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#key} */\n        it('key should not change, should be the same and not empty', (done) => {\n            const key = client.key;\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.key).toEqual(key);\n                expect(bot.key).toEqual(client.key);\n                expect(bot.key).not.toEqual('');\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.topology).toEqual(Topology.FULL_MESH);\n                expect(bot.topology).toEqual(Topology.FULL_MESH);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#signalingServer} */\n        it('Signaling server should not change', (done) => {\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.signalingServer).toEqual(SIGNALING_URL);\n                expect(bot.signalingServer).toEqual(SIGNALING_URL);\n                done();\n            })\n                .catch(fail);\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            client.invite(BOT_URL);\n            // Check bot bot\n            botWaitJoin(client.key)\n                .then(() => botGetData(client.key))\n                .then((bot) => {\n                expect(client.autoRejoin).toBeFalsy();\n                expect(bot.autoRejoin).toBeFalsy();\n                done();\n            })\n                .catch(fail);\n        });\n        describe('should send/receive', () => {\n            let called1;\n            beforeEach((done) => {\n                called1 = 0;\n                const queue = new Queue(2, () => {\n                    cleanWebGroup(client);\n                    wait(500).then(() => done());\n                });\n                client = new WebGroup(WebGroupOptions);\n                client.onMemberJoin = () => queue.done();\n                client.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        client.invite(BOT_URL);\n                        botWaitJoin(client.key).then(() => queue.done());\n                    }\n                };\n                client.join();\n            });\n            afterEach(() => {\n                cleanWebGroup(client);\n                client.leave();\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast String', (done) => {\n                const msg1 = 'sendArt is long, life is short';\n                const msgBot = 'bot: ' + msg1;\n                // Code for peer 1\n                client.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot bot\n                    wait(1000)\n                        .then(() => botGetData(client.key))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(msg1);\n                        expect(bot.messages[0].id).toEqual(client.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                client.send(msg1);\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([10, 34, 248, 157, 10, 8, 220]);\n                const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n                // Code for peer 1\n                client.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot bot\n                    wait(1000)\n                        .then(() => botGetData(client.key))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(Array.from(msg1));\n                        expect(bot.messages[0].id).toEqual(client.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                client.send(msg1);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msgBot = 'bot: ' + msg1;\n                // Code for peer 1\n                client.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot bot\n                    wait(1000)\n                        .then(() => botGetData(client.key))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(msg1);\n                        expect(bot.messages[0].id).toEqual(client.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                client.sendTo(client.members[1], msg1);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([45, 34, 248, 157, 10, 8, 220]);\n                const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n                // Code for peer 1\n                client.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot bot\n                    wait(1000)\n                        .then(() => botGetData(client.key))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(Array.from(msg1));\n                        expect(bot.messages[0].id).toEqual(client.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                client.sendTo(client.members[1], msg1);\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/2-client_bot.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 154,
    "kind": "test",
    "name": "describe87",
    "testId": 87,
    "memberof": "test/functional/2-client_bot.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87",
    "access": null,
    "description": "  - 2 members: client invites bot",
    "lineNumber": 11,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 155,
    "kind": "test",
    "name": "describe88",
    "testId": 88,
    "memberof": "test/functional/2-client_bot.test.js~describe87",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88",
    "access": null,
    "description": "invite",
    "lineNumber": 14,
    "testTargets": [
      "WebGroup#invite"
    ]
  },
  {
    "__docId__": 156,
    "kind": "test",
    "name": "it89",
    "testId": 89,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it89",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 30,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 157,
    "kind": "test",
    "name": "it90",
    "testId": 90,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it90",
    "access": null,
    "description": "Signaling state should be CHECKED",
    "lineNumber": 40,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 158,
    "kind": "test",
    "name": "it91",
    "testId": 91,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it91",
    "access": null,
    "description": "should change the WebGroup state of the bot only",
    "lineNumber": 51,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 159,
    "kind": "test",
    "name": "it92",
    "testId": 92,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it92",
    "access": null,
    "description": "WebGroup state should be JOINED for both",
    "lineNumber": 66,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 160,
    "kind": "test",
    "name": "it93",
    "testId": 93,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it93",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 79,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 161,
    "kind": "test",
    "name": "it94",
    "testId": 94,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it94",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 100,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 162,
    "kind": "test",
    "name": "it95",
    "testId": 95,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it95",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 121,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 163,
    "kind": "test",
    "name": "it96",
    "testId": 96,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it96",
    "access": null,
    "description": "should have 2 members",
    "lineNumber": 136,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 164,
    "kind": "test",
    "name": "it97",
    "testId": 97,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it97",
    "access": null,
    "description": "client's id should not change and bot's id should not be 0",
    "lineNumber": 162,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 165,
    "kind": "test",
    "name": "it98",
    "testId": 98,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it98",
    "access": null,
    "description": "WebGroup id should not change, should be the same and not 0",
    "lineNumber": 176,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 166,
    "kind": "test",
    "name": "it99",
    "testId": 99,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it99",
    "access": null,
    "description": "key should not change, should be the same and not empty",
    "lineNumber": 191,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 167,
    "kind": "test",
    "name": "it100",
    "testId": 100,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it100",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 206,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 168,
    "kind": "test",
    "name": "it101",
    "testId": 101,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it101",
    "access": null,
    "description": "Signaling server should not change",
    "lineNumber": 219,
    "testTargets": [
      "WebGroup#signalingServer"
    ]
  },
  {
    "__docId__": 169,
    "kind": "test",
    "name": "it102",
    "testId": 102,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.it102",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 232,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 170,
    "kind": "test",
    "name": "describe103",
    "testId": 103,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.describe103",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 244
  },
  {
    "__docId__": 171,
    "kind": "test",
    "name": "it104",
    "testId": 104,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88.describe103",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.describe103.it104",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 267,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 172,
    "kind": "test",
    "name": "it105",
    "testId": 105,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88.describe103",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.describe103.it105",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 291,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 173,
    "kind": "test",
    "name": "it106",
    "testId": 106,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88.describe103",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.describe103.it106",
    "access": null,
    "description": "private String",
    "lineNumber": 315,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 174,
    "kind": "test",
    "name": "it107",
    "testId": 107,
    "memberof": "test/functional/2-client_bot.test.js~describe87.describe88.describe103",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2-client_bot.test.js~describe87.describe88.describe103.it107",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 339,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 175,
    "kind": "testFile",
    "name": "test/functional/2-clients.test.js",
    "content": "/// <reference types='jasmine' />\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, cleanWebGroup, Queue, SIGNALING_URL, wait } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('  - 2 clients', () => {\n    let wg1;\n    let wg2;\n    let called1;\n    let called2;\n    /** @test {WebGroup#join} */\n    describe('join', () => {\n        beforeEach((done) => {\n            called1 = 0;\n            called2 = 0;\n            wg1 = new WebGroup(WebGroupOptions);\n            wg2 = new WebGroup(WebGroupOptions);\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    cleanWebGroup(wg1, wg2);\n                    wait(500).then(() => done());\n                }\n            };\n            wg1.join();\n        });\n        afterEach(() => {\n            cleanWebGroup(wg1, wg2);\n            wg1.leave();\n            wg2.leave();\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            const states = [];\n            const expected = [\n                SignalingState.CONNECTING,\n                SignalingState.OPEN,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n            ];\n            // Code for peer 2\n            wg2.onSignalingStateChange = (state) => {\n                states.push(state);\n                called2++;\n                if (called2 === expected.length) {\n                    wait(1000).then(() => {\n                        expect(called2).toEqual(expected.length);\n                        expect(states).toEqual(expected);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state should be CHECKED', (done) => {\n            wg2.onSignalingStateChange = (state) => {\n                called2++;\n                if (called2 === 6) {\n                    wait(1000).then(() => {\n                        expect(wg1.signalingState).toEqual(SignalingState.CHECKED);\n                        expect(wg2.signalingState).toEqual(SignalingState.CHECKED);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            const states = [];\n            const expected = [WebGroupState.JOINING, WebGroupState.JOINED];\n            // Code for peer 1\n            wg1.onStateChange = () => called1++;\n            // Code for peer 2\n            wg2.onStateChange = (state) => {\n                states.push(state);\n                called2++;\n                if (called2 === expected.length) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(2);\n                        expect(states).toEqual(expected);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#state} */\n        it('WebGroup state should be JOINED', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(wg1.state).toEqual(WebGroupState.JOINED);\n                        expect(wg2.state).toEqual(WebGroupState.JOINED);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should be notified about new member', (done) => {\n            const queue = new Queue(2, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    done();\n                });\n            });\n            // Code for peer 1\n            wg1.onMemberJoin = (id) => {\n                expect(id).toEqual(wg2.myId);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMemberJoin = (id) => {\n                expect(id).toEqual(wg1.myId);\n                called2++;\n                queue.done();\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about left member', (done) => {\n            // Code for peer 1\n            wg1.onMemberLeave = () => called1++;\n            // Code for peer 2\n            wg2.onMemberLeave = () => called2++;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            // Code for peer 1\n            wg1.onMessage = () => called1++;\n            // Code for peer 2\n            wg2.onMessage = () => called2++;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#members} */\n        it('should have 2 members', (done) => {\n            const queue = new Queue(3, () => {\n                wait(1000).then(() => {\n                    const expected = [wg1.myId, wg2.myId];\n                    expect(areTheSame(wg1.members, expected)).toBeTruthy();\n                    expect(areTheSame(wg2.members, expected)).toBeTruthy();\n                    done();\n                });\n            });\n            // Code for peer 1\n            wg1.onMemberJoin = () => {\n                expect(areTheSame(wg1.members, [wg1.myId, wg2.myId])).toBeTruthy();\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMemberJoin = () => {\n                expect(areTheSame(wg2.members, [wg1.myId, wg2.myId])).toBeTruthy();\n                queue.done();\n            };\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(areTheSame(wg2.members, [wg1.myId, wg2.myId])).toBeTruthy();\n                    queue.done();\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#myId} */\n        it(\"first client's id should not change and second client's id should not be 0\", (done) => {\n            const wg1myId = wg1.myId;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.myId).toEqual(wg1myId);\n                    expect(wg2.myId).not.toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.myId).toEqual(wg1myId);\n                        expect(wg2.myId).not.toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id should not change, should be the same and not 0', (done) => {\n            const wg1id = wg1.id;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.id).toEqual(wg1id);\n                    expect(wg2.id).toEqual(wg1.id);\n                    expect(wg2.id).not.toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.id).toEqual(wg1id);\n                        expect(wg2.id).toEqual(wg1.id);\n                        expect(wg2.id).not.toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#key} */\n        it('key should not change, should be the same and not empty', (done) => {\n            const key = wg1.key;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.key).toEqual(key);\n                    expect(wg2.key).toEqual(wg1.key);\n                    expect(wg2.key).not.toEqual('');\n                    wait(1000).then(() => {\n                        expect(wg1.key).toEqual(key);\n                        expect(wg2.key).toEqual(wg1.key);\n                        expect(wg2.key).not.toEqual('');\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                    expect(wg2.topology).toEqual(Topology.FULL_MESH);\n                    wait(1000).then(() => {\n                        expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                        expect(wg2.topology).toEqual(Topology.FULL_MESH);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#signalingServer} */\n        it('Signaling server should not change', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                    expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n                    wait(1000).then(() => {\n                        expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                        expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.autoRejoin).toBeFalsy();\n                    expect(wg2.autoRejoin).toBeFalsy();\n                    wait(1000).then(() => {\n                        expect(wg1.autoRejoin).toBeFalsy();\n                        expect(wg2.autoRejoin).toBeFalsy();\n                        done();\n                    });\n                }\n            };\n            wg2.join(wg1.key);\n        });\n        /** @test {WebGroup#join} */\n        it('should join with a specified key', (done) => {\n            const queue = new Queue(3, () => {\n                wg.leave();\n                done();\n            });\n            const key = 'ArtIsLongLifeIsShort';\n            const wg = new WebGroup(WebGroupOptions);\n            // Code for peer 1\n            wg.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wg2.join(key);\n                }\n            };\n            wg.onMemberJoin = () => queue.done();\n            // Code for peer 2\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg.key).toEqual(key);\n                    expect(wg2.key).toEqual(key);\n                    queue.done();\n                }\n            };\n            wg2.onMemberJoin = () => queue.done();\n            wg.join(key);\n        });\n    });\n    describe('should send/receive', () => {\n        beforeEach((done) => {\n            called1 = 0;\n            called2 = 0;\n            const queue = new Queue(3, () => {\n                cleanWebGroup(wg1, wg2);\n                wait(500).then(() => done());\n            });\n            wg1 = new WebGroup(WebGroupOptions);\n            wg2 = new WebGroup(WebGroupOptions);\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wg2.join(wg1.key);\n                }\n            };\n            wg1.onMemberJoin = () => queue.done();\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    queue.done();\n                }\n            };\n            wg2.onMemberJoin = () => queue.done();\n            wg1.join();\n        });\n        afterEach(() => {\n            cleanWebGroup(wg1, wg2);\n            wg1.leave();\n            wg2.leave();\n        });\n        /** @test {WebGroup#send} */\n        it('broadcast String', (done) => {\n            const msg1 = 'Art is long, life is short2';\n            const msg2 = 'Do or do not, there is no try2';\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                expect(id).toEqual(wg2.myId);\n                expect(msg).toEqual(msg2);\n                wg1.send(msg1);\n                called1++;\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                expect(id).toEqual(wg1.myId);\n                expect(msg).toEqual(msg1);\n                called2++;\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    done();\n                });\n            };\n            wg2.send(msg2);\n        });\n        /** @test {WebGroup#send} */\n        it('broadcast ArrayBuffer', (done) => {\n            const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n            const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                expect(id).toEqual(wg2.myId);\n                expect(msg instanceof Uint8Array);\n                expect(msg).toEqual(msg2);\n                wg1.send(msg1);\n                called1++;\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                expect(id).toEqual(wg1.myId);\n                expect(msg instanceof Uint8Array);\n                expect(msg).toEqual(msg1);\n                called2++;\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    done();\n                });\n            };\n            wg2.send(msg2);\n        });\n        /** @test {WebGroup#sendTo} */\n        it('private String', (done) => {\n            const msg1 = 'Art is long, life is short';\n            const msg2 = 'Do or do not, there is no try';\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                expect(id).toEqual(wg2.myId);\n                expect(msg).toEqual(msg2);\n                wg1.sendTo(wg2.myId, msg1);\n                called1++;\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                expect(id).toEqual(wg1.myId);\n                expect(msg).toEqual(msg1);\n                called2++;\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    done();\n                });\n            };\n            wg2.sendTo(wg1.myId, msg2);\n        });\n        /** @test {WebGroup#sendTo} */\n        it('private ArrayBuffer', (done) => {\n            const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n            const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                expect(id).toEqual(wg2.myId);\n                expect(msg instanceof Uint8Array);\n                expect(msg).toEqual(msg2);\n                wg1.sendTo(wg2.myId, msg1);\n                called1++;\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                expect(id).toEqual(wg1.myId);\n                expect(msg instanceof Uint8Array);\n                expect(msg).toEqual(msg1);\n                called2++;\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    done();\n                });\n            };\n            // Start sending message\n            wg2.sendTo(wg1.myId, msg2);\n        });\n    });\n    /** @test {WebGroup#leave} */\n    describe('leave', () => {\n        beforeEach((done) => {\n            called1 = 0;\n            called2 = 0;\n            const queue = new Queue(3, () => {\n                cleanWebGroup(wg1, wg2);\n                wait(500).then(() => done());\n            });\n            wg1 = new WebGroup(WebGroupOptions);\n            wg2 = new WebGroup(WebGroupOptions);\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wg2.join(wg1.key);\n                }\n            };\n            wg1.onMemberJoin = () => queue.done();\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    queue.done();\n                }\n            };\n            wg2.onMemberJoin = () => queue.done();\n            wg1.join();\n        });\n        afterEach(() => {\n            cleanWebGroup(wg1, wg2);\n            wg1.leave();\n            wg2.leave();\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should be notified about left member', (done) => {\n            const wg2peerId = wg2.myId;\n            const queue = new Queue(2, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    done();\n                });\n            });\n            // Code for peer 1\n            wg1.onMemberLeave = (id) => {\n                expect(id).toEqual(wg2peerId);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMemberLeave = (id) => {\n                expect(id).toEqual(wg1.myId);\n                called2++;\n                queue.done();\n            };\n            wg2.leave();\n        }, 12000);\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state of the second client only', (done) => {\n            // Code for peer 1\n            wg1.onStateChange = (state) => called1++;\n            // Code for peer 2\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(1);\n                        expect(wg2.state).toEqual(WebGroupState.LEFT);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        }, 12000);\n        /** @test {WebGroup#state} */\n        it('WebGroup state of the first client should be JOINED and of the second should be LEFT', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(wg1.state).toEqual(WebGroupState.JOINED);\n                        expect(wg2.state).toEqual(WebGroupState.LEFT);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            // Code for peer 2\n            wg2.onSignalingStateChange = (state) => {\n                if (state === SignalingState.CLOSED) {\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called2).toEqual(1);\n                        expect(wg2.signalingState).toEqual(SignalingState.CLOSED);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        }, 12000);\n        /** @test {WebGroup#signalingState} */\n        it('Signaling state of the first client should not be CLOSED and of the second should be CLOSED', (done) => {\n            wg2.onSignalingStateChange = (state) => {\n                if (state === SignalingState.CLOSED) {\n                    wait(1000).then(() => {\n                        expect(wg1.signalingState).not.toEqual(SignalingState.CLOSED);\n                        expect(wg2.signalingState).toEqual(SignalingState.CLOSED);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#onMemberLeave} */\n        it('should NOT be notified about joined member', (done) => {\n            // Code for peer 1\n            wg1.onMemberJoin = () => called1++;\n            // Code for peer 2\n            wg2.onMemberJoin = () => called2++;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#onMessage} */\n        it('should NOT receive any message', (done) => {\n            // Code for peer 1\n            wg1.onMessage = () => called1++;\n            // Code for peer 2\n            wg2.onMessage = () => called2++;\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#members} */\n        it('first client should have only him as a member and second client should have no members', (done) => {\n            const queue = new Queue(2, () => {\n                wait(1000).then(() => {\n                    expect(wg1.members).toEqual([wg1.myId]);\n                    expect(wg2.members).toEqual([]);\n                    done();\n                });\n            });\n            // Code for peer 1\n            wg1.onMemberLeave = () => {\n                expect(wg1.members).toEqual([wg1.myId]);\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg2.members).toEqual([]);\n                    queue.done();\n                }\n            };\n            wg2.leave();\n        }, 10000);\n        /** @test {WebGroup#myId} */\n        it('the id of the first client should NOT be 0 and of second should be 0', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.myId).not.toEqual(0);\n                    expect(wg2.myId).toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.myId).not.toEqual(0);\n                        expect(wg2.myId).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#id} */\n        it('WebGroup id of the first client should NOT be 0 and of second should be 0', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.id).not.toEqual(0);\n                    expect(wg2.id).toEqual(0);\n                    wait(1000).then(() => {\n                        expect(wg1.id).not.toEqual(0);\n                        expect(wg2.id).toEqual(0);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#key} */\n        it('key of the first client should NOT be empty and of second should be empty', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.key).not.toEqual('');\n                    expect(wg2.key).toEqual('');\n                    wait(1000).then(() => {\n                        expect(wg1.key).not.toEqual('');\n                        expect(wg2.key).toEqual('');\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#topology} */\n        it('topology should not change', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                    expect(wg2.topology).toEqual(Topology.FULL_MESH);\n                    wait(1000).then(() => {\n                        expect(wg1.topology).toEqual(Topology.FULL_MESH);\n                        expect(wg2.topology).toEqual(Topology.FULL_MESH);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#signalingServer} */\n        it('Signaling server should not change', (done) => {\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                    expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n                    wait(1000).then(() => {\n                        expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n                        expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n        /** @test {WebGroup#autoRejoin} */\n        it('autoRejoin should be disabled', (done) => {\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg1.autoRejoin).toBeFalsy();\n                    wait(1000).then(() => {\n                        expect(wg1.autoRejoin).toBeFalsy();\n                        done();\n                    });\n                }\n            };\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.LEFT) {\n                    expect(wg1.autoRejoin).toBeFalsy();\n                    expect(wg2.autoRejoin).toBeFalsy();\n                    wait(1000).then(() => {\n                        expect(wg1.autoRejoin).toBeFalsy();\n                        expect(wg2.autoRejoin).toBeFalsy();\n                        done();\n                    });\n                }\n            };\n            wg2.leave();\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/2-clients.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 176,
    "kind": "test",
    "name": "describe108",
    "testId": 108,
    "memberof": "test/functional/2-clients.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108",
    "access": null,
    "description": "  - 2 clients",
    "lineNumber": 9,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 177,
    "kind": "test",
    "name": "describe109",
    "testId": 109,
    "memberof": "test/functional/2-clients.test.js~describe108",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109",
    "access": null,
    "description": "join",
    "lineNumber": 15,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 178,
    "kind": "test",
    "name": "it110",
    "testId": 110,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it110",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 35,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 179,
    "kind": "test",
    "name": "it111",
    "testId": 111,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it111",
    "access": null,
    "description": "Signaling state should be CHECKED",
    "lineNumber": 60,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 180,
    "kind": "test",
    "name": "it112",
    "testId": 112,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it112",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 74,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 181,
    "kind": "test",
    "name": "it113",
    "testId": 113,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it113",
    "access": null,
    "description": "WebGroup state should be JOINED",
    "lineNumber": 95,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 182,
    "kind": "test",
    "name": "it114",
    "testId": 114,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it114",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 108,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 183,
    "kind": "test",
    "name": "it115",
    "testId": 115,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it115",
    "access": null,
    "description": "should NOT be notified about left member",
    "lineNumber": 131,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 184,
    "kind": "test",
    "name": "it116",
    "testId": 116,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it116",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 148,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 185,
    "kind": "test",
    "name": "it117",
    "testId": 117,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it117",
    "access": null,
    "description": "should have 2 members",
    "lineNumber": 165,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 186,
    "kind": "test",
    "name": "it118",
    "testId": 118,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it118",
    "access": null,
    "description": "first client's id should not change and second client's id should not be 0",
    "lineNumber": 193,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 187,
    "kind": "test",
    "name": "it119",
    "testId": 119,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it119",
    "access": null,
    "description": "WebGroup id should not change, should be the same and not 0",
    "lineNumber": 209,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 188,
    "kind": "test",
    "name": "it120",
    "testId": 120,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it120",
    "access": null,
    "description": "key should not change, should be the same and not empty",
    "lineNumber": 227,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 189,
    "kind": "test",
    "name": "it121",
    "testId": 121,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it121",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 245,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 190,
    "kind": "test",
    "name": "it122",
    "testId": 122,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it122",
    "access": null,
    "description": "Signaling server should not change",
    "lineNumber": 260,
    "testTargets": [
      "WebGroup#signalingServer"
    ]
  },
  {
    "__docId__": 191,
    "kind": "test",
    "name": "it123",
    "testId": 123,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it123",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 275,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 192,
    "kind": "test",
    "name": "it124",
    "testId": 124,
    "memberof": "test/functional/2-clients.test.js~describe108.describe109",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe109.it124",
    "access": null,
    "description": "should join with a specified key",
    "lineNumber": 290,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 193,
    "kind": "test",
    "name": "describe125",
    "testId": 125,
    "memberof": "test/functional/2-clients.test.js~describe108",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe125",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 316
  },
  {
    "__docId__": 194,
    "kind": "test",
    "name": "it126",
    "testId": 126,
    "memberof": "test/functional/2-clients.test.js~describe108.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe125.it126",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 346,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 195,
    "kind": "test",
    "name": "it127",
    "testId": 127,
    "memberof": "test/functional/2-clients.test.js~describe108.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe125.it127",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 370,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 196,
    "kind": "test",
    "name": "it128",
    "testId": 128,
    "memberof": "test/functional/2-clients.test.js~describe108.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe125.it128",
    "access": null,
    "description": "private String",
    "lineNumber": 396,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 197,
    "kind": "test",
    "name": "it129",
    "testId": 129,
    "memberof": "test/functional/2-clients.test.js~describe108.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe125.it129",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 420,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 198,
    "kind": "test",
    "name": "describe130",
    "testId": 130,
    "memberof": "test/functional/2-clients.test.js~describe108",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130",
    "access": null,
    "description": "leave",
    "lineNumber": 448,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 199,
    "kind": "test",
    "name": "it131",
    "testId": 131,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it131",
    "access": null,
    "description": "should be notified about left member",
    "lineNumber": 478,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 200,
    "kind": "test",
    "name": "it132",
    "testId": 132,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it132",
    "access": null,
    "description": "should change the WebGroup state of the second client only",
    "lineNumber": 502,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 201,
    "kind": "test",
    "name": "it133",
    "testId": 133,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it133",
    "access": null,
    "description": "WebGroup state of the first client should be JOINED and of the second should be LEFT",
    "lineNumber": 520,
    "testTargets": [
      "WebGroup#state"
    ]
  },
  {
    "__docId__": 202,
    "kind": "test",
    "name": "it134",
    "testId": 134,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it134",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 533,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 203,
    "kind": "test",
    "name": "it135",
    "testId": 135,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it135",
    "access": null,
    "description": "Signaling state of the first client should not be CLOSED and of the second should be CLOSED",
    "lineNumber": 548,
    "testTargets": [
      "WebGroup#signalingState"
    ]
  },
  {
    "__docId__": 204,
    "kind": "test",
    "name": "it136",
    "testId": 136,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it136",
    "access": null,
    "description": "should NOT be notified about joined member",
    "lineNumber": 561,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 205,
    "kind": "test",
    "name": "it137",
    "testId": 137,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it137",
    "access": null,
    "description": "should NOT receive any message",
    "lineNumber": 578,
    "testTargets": [
      "WebGroup#onMessage"
    ]
  },
  {
    "__docId__": 206,
    "kind": "test",
    "name": "it138",
    "testId": 138,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it138",
    "access": null,
    "description": "first client should have only him as a member and second client should have no members",
    "lineNumber": 595,
    "testTargets": [
      "WebGroup#members"
    ]
  },
  {
    "__docId__": 207,
    "kind": "test",
    "name": "it139",
    "testId": 139,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it139",
    "access": null,
    "description": "the id of the first client should NOT be 0 and of second should be 0",
    "lineNumber": 618,
    "testTargets": [
      "WebGroup#myId"
    ]
  },
  {
    "__docId__": 208,
    "kind": "test",
    "name": "it140",
    "testId": 140,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it140",
    "access": null,
    "description": "WebGroup id of the first client should NOT be 0 and of second should be 0",
    "lineNumber": 633,
    "testTargets": [
      "WebGroup#id"
    ]
  },
  {
    "__docId__": 209,
    "kind": "test",
    "name": "it141",
    "testId": 141,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it141",
    "access": null,
    "description": "key of the first client should NOT be empty and of second should be empty",
    "lineNumber": 648,
    "testTargets": [
      "WebGroup#key"
    ]
  },
  {
    "__docId__": 210,
    "kind": "test",
    "name": "it142",
    "testId": 142,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it142",
    "access": null,
    "description": "topology should not change",
    "lineNumber": 663,
    "testTargets": [
      "WebGroup#topology"
    ]
  },
  {
    "__docId__": 211,
    "kind": "test",
    "name": "it143",
    "testId": 143,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it143",
    "access": null,
    "description": "Signaling server should not change",
    "lineNumber": 678,
    "testTargets": [
      "WebGroup#signalingServer"
    ]
  },
  {
    "__docId__": 212,
    "kind": "test",
    "name": "it144",
    "testId": 144,
    "memberof": "test/functional/2-clients.test.js~describe108.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2-clients.test.js~describe108.describe130.it144",
    "access": null,
    "description": "autoRejoin should be disabled",
    "lineNumber": 693,
    "testTargets": [
      "WebGroup#autoRejoin"
    ]
  },
  {
    "__docId__": 213,
    "kind": "testFile",
    "name": "test/functional/3-bot_client_client.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, botGetData, botJoin, randomKey, SIGNALING_URL } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('   - 3 members: 1 bot and 2 clients', () => {\n    /** @test {WebGroup#join} */\n    it('join', (done) => {\n        const key = randomKey();\n        let wgId;\n        const wg1 = new WebGroup(WebGroupOptions);\n        const wg1JoinedMembers = [];\n        const wg1LeftMembers = [];\n        let wg1OnMessageCalled = 0;\n        const wg2 = new WebGroup(WebGroupOptions);\n        const wg2LeftMembers = [];\n        const wg2JoinedMembers = [];\n        let wg2OnMessageCalled = 0;\n        wg1.onMessage = () => wg1OnMessageCalled++;\n        wg1.onMemberJoin = (id) => wg1JoinedMembers.push(id);\n        wg1.onMemberLeave = (id) => wg1LeftMembers.push(id);\n        wg1.onMessage = () => wg2OnMessageCalled++;\n        wg2.onMemberJoin = (id) => wg2JoinedMembers.push(id);\n        wg2.onMemberLeave = (id) => wg2LeftMembers.push(id);\n        botJoin(key)\n            .then(() => botGetData(key))\n            .then((bot) => (wgId = bot.id))\n            .then(() => {\n            wg1.join(key);\n            return new Promise((resolve) => {\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        resolve();\n                    }\n                };\n            });\n        })\n            .then(() => {\n            wg2.join(key);\n            return new Promise((resolve) => {\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        resolve();\n                    }\n                };\n            });\n        })\n            .then(() => botGetData(key))\n            .then((bot) => {\n            const expectedMembers = [wg1.myId, wg2.myId, bot.myId];\n            // Expect for the first client\n            expect(wg1.state).toEqual(WebGroupState.JOINED);\n            expect(wg1.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(wg1OnMessageCalled).toEqual(0);\n            expect(wg1.key).toEqual(key);\n            expect(wg1.id).toEqual(wgId);\n            expect(wg1.topology).toEqual(Topology.FULL_MESH);\n            expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n            expect(wg1.autoRejoin).toBeFalsy();\n            expect(areTheSame(wg1.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(wg1JoinedMembers, [wg2.myId, bot.myId])).toBeTruthy();\n            expect(areTheSame(wg1LeftMembers, [])).toBeTruthy();\n            // Expect for the second client\n            expect(wg2.state).toEqual(WebGroupState.JOINED);\n            expect(wg2.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(wg2OnMessageCalled).toEqual(0);\n            expect(wg2.key).toEqual(key);\n            expect(wg2.id).toEqual(wgId);\n            expect(wg2.topology).toEqual(Topology.FULL_MESH);\n            expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n            expect(wg2.autoRejoin).toBeFalsy();\n            expect(areTheSame(wg2.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(wg2JoinedMembers, [wg1.myId, bot.myId])).toBeTruthy();\n            expect(areTheSame(wg2LeftMembers, [])).toBeTruthy();\n            // Expect for the bot\n            expect(bot.state).toEqual(WebGroupState.JOINED);\n            expect(bot.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(bot.onMessageToBeCalled).toEqual(0);\n            expect(bot.key).toEqual(key);\n            expect(bot.id).toEqual(wgId);\n            expect(bot.topology).toEqual(Topology.FULL_MESH);\n            expect(bot.signalingServer).toEqual(SIGNALING_URL);\n            expect(bot.autoRejoin).toBeFalsy();\n            expect(areTheSame(bot.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(bot.joinedMembers, [wg1.myId, wg2.myId])).toBeTruthy();\n            expect(areTheSame(bot.leftMembers, [])).toBeTruthy();\n            done();\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/3-bot_client_client.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 214,
    "kind": "test",
    "name": "describe145",
    "testId": 145,
    "memberof": "test/functional/3-bot_client_client.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/3-bot_client_client.test.js~describe145",
    "access": null,
    "description": "   - 3 members: 1 bot and 2 clients",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 215,
    "kind": "test",
    "name": "it146",
    "testId": 146,
    "memberof": "test/functional/3-bot_client_client.test.js~describe145",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/3-bot_client_client.test.js~describe145.it146",
    "access": null,
    "description": "join",
    "lineNumber": 12,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 216,
    "kind": "testFile",
    "name": "test/functional/3-client_bot_client.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, BOT_URL, botGetData, botWaitJoin, randomKey, SIGNALING_URL, } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('   - 3 members: 1 client, 1 bot and 1 client', () => {\n    /** @test {WebGroup#join} */\n    it('join', (done) => {\n        const key = randomKey();\n        let wgId;\n        const wg1 = new WebGroup(WebGroupOptions);\n        wgId = wg1.id;\n        const wg1JoinedMembers = [];\n        const wg1LeftMembers = [];\n        let wg1OnMessageCalled = 0;\n        const wg2 = new WebGroup(WebGroupOptions);\n        const wg2LeftMembers = [];\n        const wg2JoinedMembers = [];\n        let wg2OnMessageCalled = 0;\n        wg1.onMessage = () => wg1OnMessageCalled++;\n        wg1.onMemberJoin = (id) => wg1JoinedMembers.push(id);\n        wg1.onMemberLeave = (id) => wg1LeftMembers.push(id);\n        wg1.onStateChange = (state) => {\n            if (state === WebGroupState.JOINED) {\n                wgId = wg1.id;\n                wg1.invite(BOT_URL);\n            }\n        };\n        wg1.onMessage = () => wg2OnMessageCalled++;\n        wg2.onMemberJoin = (id) => wg2JoinedMembers.push(id);\n        wg2.onMemberLeave = (id) => wg2LeftMembers.push(id);\n        botWaitJoin(key)\n            .then(() => {\n            wg2.join(key);\n            return new Promise((resolve) => {\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        resolve();\n                    }\n                };\n            });\n        })\n            .then(() => botGetData(key))\n            .then((bot) => {\n            const expectedMembers = [wg1.myId, wg2.myId, bot.myId];\n            // Expect for the first client\n            expect(wg1.state).toEqual(WebGroupState.JOINED);\n            expect(wg1.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(wg1OnMessageCalled).toEqual(0);\n            expect(wg1.key).toEqual(key);\n            expect(wg1.id).toEqual(wgId);\n            expect(wg1.topology).toEqual(Topology.FULL_MESH);\n            expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n            expect(wg1.autoRejoin).toBeFalsy();\n            expect(areTheSame(wg1.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(wg1JoinedMembers, [wg2.myId, bot.myId])).toBeTruthy();\n            expect(areTheSame(wg1LeftMembers, [])).toBeTruthy();\n            // Expect for the second client\n            expect(wg2.state).toEqual(WebGroupState.JOINED);\n            expect(wg2.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(wg2OnMessageCalled).toEqual(0);\n            expect(wg2.key).toEqual(key);\n            expect(wg2.id).toEqual(wgId);\n            expect(wg2.topology).toEqual(Topology.FULL_MESH);\n            expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n            expect(wg2.autoRejoin).toBeFalsy();\n            expect(areTheSame(wg2.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(wg2JoinedMembers, [wg1.myId, bot.myId])).toBeTruthy();\n            expect(areTheSame(wg2LeftMembers, [])).toBeTruthy();\n            // Expect for the bot\n            expect(bot.state).toEqual(WebGroupState.JOINED);\n            expect(bot.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(bot.onMessageToBeCalled).toEqual(0);\n            expect(bot.key).toEqual(key);\n            expect(bot.id).toEqual(wgId);\n            expect(bot.topology).toEqual(Topology.FULL_MESH);\n            expect(bot.signalingServer).toEqual(SIGNALING_URL);\n            expect(bot.autoRejoin).toBeFalsy();\n            expect(areTheSame(bot.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(bot.joinedMembers, [wg1.myId, wg2.myId])).toBeTruthy();\n            expect(areTheSame(bot.leftMembers, [])).toBeTruthy();\n            done();\n        });\n        wg1.join(key);\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/3-client_bot_client.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 217,
    "kind": "test",
    "name": "describe147",
    "testId": 147,
    "memberof": "test/functional/3-client_bot_client.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/3-client_bot_client.test.js~describe147",
    "access": null,
    "description": "   - 3 members: 1 client, 1 bot and 1 client",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 218,
    "kind": "test",
    "name": "it148",
    "testId": 148,
    "memberof": "test/functional/3-client_bot_client.test.js~describe147",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/3-client_bot_client.test.js~describe147.it148",
    "access": null,
    "description": "join",
    "lineNumber": 12,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 219,
    "kind": "testFile",
    "name": "test/functional/3-client_client_bot.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, BOT_URL, botGetData, botWaitJoin, randomKey, SIGNALING_URL, } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('   - 3 members: 2 clients and 1 bot', () => {\n    /** @test {WebGroup#invite} */\n    it('join', (done) => {\n        const key = randomKey();\n        const wg1 = new WebGroup(WebGroupOptions);\n        let wgId = wg1.id;\n        const wg1JoinedMembers = [];\n        const wg1LeftMembers = [];\n        let wg1OnMessageCalled = 0;\n        const wg2 = new WebGroup(WebGroupOptions);\n        const wg2LeftMembers = [];\n        const wg2JoinedMembers = [];\n        let wg2OnMessageCalled = 0;\n        wg1.onMessage = () => wg1OnMessageCalled++;\n        wg1.onMemberJoin = (id) => wg1JoinedMembers.push(id);\n        wg1.onMemberLeave = (id) => wg1LeftMembers.push(id);\n        wg1.onStateChange = (state) => {\n            if (state === WebGroupState.JOINED) {\n                wgId = wg1.id;\n                wg2.join(key);\n            }\n        };\n        wg1.onMessage = () => wg2OnMessageCalled++;\n        wg2.onMemberJoin = (id) => wg2JoinedMembers.push(id);\n        wg2.onMemberLeave = (id) => wg2LeftMembers.push(id);\n        wg2.onStateChange = (state) => {\n            if (state === WebGroupState.JOINED) {\n                wg2.invite(BOT_URL);\n            }\n        };\n        botWaitJoin(key)\n            .then(() => botGetData(key))\n            .then((bot) => {\n            const expectedMembers = [wg1.myId, wg2.myId, bot.myId];\n            // Expect for the first client\n            expect(wg1.state).toEqual(WebGroupState.JOINED);\n            expect(wg1.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(wg1OnMessageCalled).toEqual(0);\n            expect(wg1.key).toEqual(key);\n            expect(wg1.id).toEqual(wgId);\n            expect(wg1.topology).toEqual(Topology.FULL_MESH);\n            expect(wg1.signalingServer).toEqual(SIGNALING_URL);\n            expect(wg1.autoRejoin).toBeFalsy();\n            expect(areTheSame(wg1.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(wg1JoinedMembers, [wg2.myId, bot.myId])).toBeTruthy();\n            expect(areTheSame(wg1LeftMembers, [])).toBeTruthy();\n            // Expect for the second client\n            expect(wg2.state).toEqual(WebGroupState.JOINED);\n            expect(wg2.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(wg2OnMessageCalled).toEqual(0);\n            expect(wg2.key).toEqual(key);\n            expect(wg2.id).toEqual(wgId);\n            expect(wg2.topology).toEqual(Topology.FULL_MESH);\n            expect(wg2.signalingServer).toEqual(SIGNALING_URL);\n            expect(wg2.autoRejoin).toBeFalsy();\n            expect(areTheSame(wg2.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(wg2JoinedMembers, [wg1.myId, bot.myId])).toBeTruthy();\n            expect(areTheSame(wg2LeftMembers, [])).toBeTruthy();\n            // Expect for the bot\n            expect(bot.state).toEqual(WebGroupState.JOINED);\n            expect(bot.signalingState).not.toEqual(SignalingState.CLOSED);\n            expect(bot.onMessageToBeCalled).toEqual(0);\n            expect(bot.key).toEqual(key);\n            expect(bot.id).toEqual(wgId);\n            expect(bot.topology).toEqual(Topology.FULL_MESH);\n            expect(bot.signalingServer).toEqual(SIGNALING_URL);\n            expect(bot.autoRejoin).toBeFalsy();\n            expect(areTheSame(bot.members, expectedMembers)).toBeTruthy();\n            expect(areTheSame(bot.joinedMembers, [wg1.myId, wg2.myId])).toBeTruthy();\n            expect(areTheSame(bot.leftMembers, [])).toBeTruthy();\n            done();\n        });\n        wg1.join(key);\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/3-client_client_bot.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 220,
    "kind": "test",
    "name": "describe149",
    "testId": 149,
    "memberof": "test/functional/3-client_client_bot.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/3-client_client_bot.test.js~describe149",
    "access": null,
    "description": "   - 3 members: 2 clients and 1 bot",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 221,
    "kind": "test",
    "name": "it150",
    "testId": 150,
    "memberof": "test/functional/3-client_client_bot.test.js~describe149",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/3-client_client_bot.test.js~describe149.it150",
    "access": null,
    "description": "join",
    "lineNumber": 12,
    "testTargets": [
      "WebGroup#invite"
    ]
  },
  {
    "__docId__": 222,
    "kind": "testFile",
    "name": "test/functional/3-clients.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, cleanWebGroup, Queue, SIGNALING_URL, wait } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('   - 3 clients', () => {\n    let wg1, wg2, wg3;\n    let called1, called2, called3;\n    /** @test {WebGroup#join} */\n    describe('join', () => {\n        beforeEach((done) => {\n            called1 = 0;\n            called2 = 0;\n            called3 = 0;\n            const queue = new Queue(3, () => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                cleanWebGroup(wg3);\n                done();\n            });\n            wg1 = new WebGroup(WebGroupOptions);\n            wg2 = new WebGroup(WebGroupOptions);\n            wg3 = new WebGroup(WebGroupOptions);\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    wg2.join(wg1.key);\n                }\n            };\n            wg1.onMemberJoin = () => queue.done();\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    queue.done();\n                }\n            };\n            wg2.onMemberJoin = () => queue.done();\n            wg1.join();\n        });\n        afterEach(() => {\n            cleanWebGroup(wg1);\n            cleanWebGroup(wg2);\n            cleanWebGroup(wg3);\n            wg1.leave();\n            wg2.leave();\n            wg3.leave();\n        });\n        /** @test {WebGroup#onSignalingStateChange} */\n        it('should change the Signaling state', (done) => {\n            const states = [];\n            const expected = [\n                SignalingState.CONNECTING,\n                SignalingState.OPEN,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n                SignalingState.CHECKING,\n                SignalingState.CHECKED,\n            ];\n            // Code for peer 3\n            wg3.onSignalingStateChange = (state) => {\n                states.push(state);\n                called3++;\n                if (called3 === expected.length) {\n                    wait(1000).then(() => {\n                        expect(called3).toEqual(6);\n                        expect(states).toEqual(expected);\n                        expect(wg3.signalingState).toEqual(SignalingState.CHECKED);\n                        done();\n                    });\n                }\n            };\n            wg3.join(wg1.key);\n        });\n        /** @test {WebGroup#onStateChange} */\n        it('should change the WebGroup state', (done) => {\n            const states = [];\n            const expected = [WebGroupState.JOINING, WebGroupState.JOINED];\n            // Code for peer 1\n            wg1.onStateChange = () => called1++;\n            // Code for peer 2\n            wg2.onStateChange = () => called2++;\n            // Code for peer 3\n            wg3.onStateChange = (state) => {\n                states.push(state);\n                called3++;\n                if (called3 === expected.length) {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(0);\n                        expect(called2).toEqual(0);\n                        expect(called3).toEqual(2);\n                        expect(states).toEqual(expected);\n                        expect(wg3.state).toEqual(WebGroupState.JOINED);\n                        done();\n                    });\n                }\n            };\n            wg3.join(wg1.key);\n        });\n        /** @test {WebGroup#onMemberJoin} */\n        it('should be notified about new member', (done) => {\n            const members3 = [];\n            const expectedMembers3 = [wg1.myId, wg2.myId];\n            const queue = new Queue(3, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(members3, expectedMembers3)).toBeTruthy();\n                    done();\n                });\n            });\n            // Code for peer 1\n            wg1.onMemberJoin = (id) => {\n                expect(id).toEqual(wg3.myId);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMemberJoin = (id) => {\n                expect(id).toEqual(wg3.myId);\n                called2++;\n                queue.done();\n            };\n            // Code for peer 3\n            wg3.onMemberJoin = (id) => {\n                members3.push(id);\n                called3++;\n                if (called3 === 2) {\n                    queue.done();\n                }\n            };\n            wg3.join(wg1.key);\n        });\n        it('should have the same members, key, WebGroup id, topology once joined', (done) => {\n            const queue = new Queue(3, () => {\n                wait(1000).then(() => {\n                    expect(areTheSame(wg3.members, wg1.members)).toBeTruthy();\n                    expect(areTheSame(wg3.members, wg2.members)).toBeTruthy();\n                    expect(wg3.id).toEqual(wg1.id);\n                    expect(wg3.key).toEqual(wg1.key);\n                    expect(wg3.topology).toEqual(wg1.topology);\n                    done();\n                });\n            });\n            // Code for peer 1\n            wg1.onMemberJoin = () => queue.done();\n            // Code for peer 2\n            wg2.onMemberJoin = () => queue.done();\n            // Code for peer 3\n            wg3.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    expect(wg3.members.length).toEqual(3);\n                    expect(wg3.members.includes(wg1.myId)).toBeTruthy();\n                    expect(wg3.members.includes(wg2.myId)).toBeTruthy();\n                    expect(wg3.members.includes(wg3.myId)).toBeTruthy();\n                    expect(wg3.id).toEqual(wg1.id);\n                    expect(wg3.key).toEqual(wg1.key);\n                    expect(wg3.topology).toEqual(wg1.topology);\n                    queue.done();\n                }\n            };\n            wg3.join(wg1.key);\n        });\n    });\n    describe('should send/receive', () => {\n        beforeEach((done) => {\n            called1 = 0;\n            called2 = 0;\n            called3 = 0;\n            const queue = new Queue(9, () => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                cleanWebGroup(wg3);\n                done();\n            });\n            wg1 = new WebGroup(WebGroupOptions);\n            wg2 = new WebGroup(WebGroupOptions);\n            wg3 = new WebGroup(WebGroupOptions);\n            wg1.onMemberJoin = () => queue.done();\n            wg1.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    queue.done();\n                    wg2.join(wg1.key);\n                }\n            };\n            wg2.onMemberJoin = () => queue.done();\n            wg2.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    queue.done();\n                    wg3.join(wg1.key);\n                }\n            };\n            wg3.onMemberJoin = () => queue.done();\n            wg3.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    queue.done();\n                }\n            };\n            wg1.join();\n        });\n        afterEach(() => {\n            cleanWebGroup(wg1);\n            cleanWebGroup(wg2);\n            cleanWebGroup(wg3);\n            wg1.leave();\n            wg2.leave();\n            wg3.leave();\n        });\n        /** @test {WebGroup#send} */\n        it('broadcast String', (done) => {\n            const queue = new Queue(6, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2, msg3])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1, msg3])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2, msg1])).toBeTruthy();\n                    done();\n                });\n            });\n            const msg1 = 'Art is long, life is short';\n            const msg2 = 'Do or do not, there is no try';\n            const msg3 = 'Never say never';\n            const messages1 = { ids: [], msgs: [] };\n            const messages2 = { ids: [], msgs: [] };\n            const messages3 = { ids: [], msgs: [] };\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                messages1.ids.push(id);\n                messages1.msgs.push(msg);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                messages2.ids.push(id);\n                messages2.msgs.push(msg);\n                called2++;\n                queue.done();\n            };\n            // Code for peer 3\n            wg3.onMessage = (id, msg) => {\n                messages3.ids.push(id);\n                messages3.msgs.push(msg);\n                called3++;\n                queue.done();\n            };\n            // Start sending message\n            wg1.send(msg1);\n            wg2.send(msg2);\n            wg3.send(msg3);\n        });\n        /** @test {WebGroup#send} */\n        it('broadcast ArrayBuffer', (done) => {\n            const queue = new Queue(6, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2, msg3])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1, msg3])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2, msg1])).toBeTruthy();\n                    done();\n                });\n            });\n            const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n            const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n            const msg3 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 44]);\n            const messages1 = { ids: [], msgs: [] };\n            const messages2 = { ids: [], msgs: [] };\n            const messages3 = { ids: [], msgs: [] };\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                expect(msg instanceof Uint8Array).toBeTruthy();\n                messages1.ids.push(id);\n                messages1.msgs.push(msg);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                expect(msg instanceof Uint8Array).toBeTruthy();\n                messages2.ids.push(id);\n                messages2.msgs.push(msg);\n                called2++;\n                queue.done();\n            };\n            // Code for peer 3\n            wg3.onMessage = (id, msg) => {\n                expect(msg instanceof Uint8Array).toBeTruthy();\n                messages3.ids.push(id);\n                messages3.msgs.push(msg);\n                called3++;\n                queue.done();\n            };\n            // Start sending message\n            wg1.send(msg1);\n            wg2.send(msg2);\n            wg3.send(msg3);\n        });\n        /** @test {WebGroup#sendTo} */\n        it('private String', (done) => {\n            const queue = new Queue(6, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2For1, msg3For1])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1For2, msg3For2])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2For3, msg1For3])).toBeTruthy();\n                    done();\n                });\n            });\n            const msg1For2 = 'Art is long, life is short2';\n            const msg1For3 = 'Art is long, life is short3';\n            const msg2For1 = 'Do or do not, there is no try1';\n            const msg2For3 = 'Do or do not, there is no try3';\n            const msg3For1 = 'Never say never1';\n            const msg3For2 = 'Never say never2';\n            const messages1 = { ids: [], msgs: [] };\n            const messages2 = { ids: [], msgs: [] };\n            const messages3 = { ids: [], msgs: [] };\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                messages1.ids.push(id);\n                messages1.msgs.push(msg);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                messages2.ids.push(id);\n                messages2.msgs.push(msg);\n                called2++;\n                queue.done();\n            };\n            // Code for peer 3\n            wg3.onMessage = (id, msg) => {\n                messages3.ids.push(id);\n                messages3.msgs.push(msg);\n                called3++;\n                queue.done();\n            };\n            // Start sending message\n            wg1.sendTo(wg2.myId, msg1For2);\n            wg1.sendTo(wg3.myId, msg1For3);\n            wg2.sendTo(wg1.myId, msg2For1);\n            wg2.sendTo(wg3.myId, msg2For3);\n            wg3.sendTo(wg1.myId, msg3For1);\n            wg3.sendTo(wg2.myId, msg3For2);\n        });\n        /** @test {WebGroup#sendTo} */\n        it('private ArrayBuffer', (done) => {\n            const queue = new Queue(6, () => {\n                wait(1000).then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2For1, msg3For1])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1For2, msg3For2])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2For3, msg1For3])).toBeTruthy();\n                    done();\n                });\n            });\n            const msg1For2 = new Uint8Array([42, 347, 248247, 583, 10, 8, 2]);\n            const msg1For3 = new Uint8Array([42, 347, 248247, 583, 10, 8, 3]);\n            const msg2For1 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 1]);\n            const msg2For3 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 3]);\n            const msg3For1 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 1]);\n            const msg3For2 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 2]);\n            const messages1 = { ids: [], msgs: [] };\n            const messages2 = { ids: [], msgs: [] };\n            const messages3 = { ids: [], msgs: [] };\n            // Code for peer 1\n            wg1.onMessage = (id, msg) => {\n                expect(msg instanceof Uint8Array).toBeTruthy();\n                messages1.ids.push(id);\n                messages1.msgs.push(msg);\n                called1++;\n                queue.done();\n            };\n            // Code for peer 2\n            wg2.onMessage = (id, msg) => {\n                expect(msg instanceof Uint8Array).toBeTruthy();\n                messages2.ids.push(id);\n                messages2.msgs.push(msg);\n                called2++;\n                queue.done();\n            };\n            // Code for peer 3\n            wg3.onMessage = (id, msg) => {\n                expect(msg instanceof Uint8Array).toBeTruthy();\n                messages3.ids.push(id);\n                messages3.msgs.push(msg);\n                called3++;\n                queue.done();\n            };\n            // Start sending message\n            wg1.sendTo(wg2.myId, msg1For2);\n            wg1.sendTo(wg3.myId, msg1For3);\n            wg2.sendTo(wg1.myId, msg2For1);\n            wg2.sendTo(wg3.myId, msg2For3);\n            wg3.sendTo(wg1.myId, msg3For1);\n            wg3.sendTo(wg2.myId, msg3For2);\n        });\n    });\n    // TODO: finish test\n    xdescribe('leave', () => {\n        // beforeEach((done) => {\n        //   called1 = 0\n        //   called2 = 0\n        //   called3 = 0\n        //   const queue = new Queue(4)\n        //   queue.wait().then(() => {\n        //     cleanWebGroup(wg1)\n        //     cleanWebGroup(wg2)\n        //     cleanWebGroup(wg3)\n        //     done()\n        //   })\n        //   wg1 = new WebGroup(WebGroupOptions)\n        //   wg2 = new WebGroup(WebGroupOptions)\n        //   wg3 = new WebGroup(WebGroupOptions)\n        //   wg1.onSignalingStateChange = (state: SignalingState) => {\n        //     if (state === SignalingState.STABLE) {\n        //       wg2.join(wg1.key)\n        //     }\n        //   }\n        //   wg1.onMemberJoin = () => queue.done()\n        //   wg2.onStateChange = (state: WebGroupState) => {\n        //     if (state === WebGroupState.JOINED) {\n        //       queue.done()\n        //     }\n        //   }\n        //   wg2.onSignalingStateChange = (state: SignalingState) => {\n        //     if (state === SignalingState.STABLE) {\n        //       queue.done()\n        //     }\n        //   }\n        //   wg2.onMemberJoin = () => queue.done()\n        //   wg1.join()\n        // })\n        // afterEach((done) => {\n        //   cleanWebGroup(wg1)\n        //   cleanWebGroup(wg2)\n        //   cleanWebGroup(wg3)\n        //   const queue = new Queue(3)\n        //   if (wg1.state !== WebGroup.LEFT) {\n        //     wg1.onStateChange = (state: WebGroupState) => {\n        //       if (state === WebGroup.LEFT) {\n        //         queue.done()\n        //       }\n        //     }\n        //     wg1.leave()\n        //   } else {\n        //     queue.done()\n        //   }\n        //   if (wg2.state !== WebGroup.LEFT) {\n        //     wg2.onStateChange = (state: WebGroupState) => {\n        //       if (state === WebGroup.LEFT) {\n        //         queue.done()\n        //       }\n        //     }\n        //     wg2.leave()\n        //   } else {\n        //     queue.done()\n        //   }\n        //   if (wg3.state !== WebGroup.LEFT) {\n        //     wg3.onStateChange = (state: WebGroupState) => {\n        //       if (state === WebGroup.LEFT) {\n        //         queue.done()\n        //       }\n        //     }\n        //     wg3.leave()\n        //   } else {\n        //     queue.done()\n        //   }\n        //   queue.wait().then(() => {\n        //     cleanWebGroup(wg1)\n        //     cleanWebGroup(wg2)\n        //     cleanWebGroup(wg3)\n        //     done()\n        //   })\n        // })\n        // /** @test {WebGroup#leave} */\n        // it('should have no members & an empty key', (done) => {\n        //   const queue = new Queue(1)\n        //   // Code for peer 1\n        //   wg1.onMemberLeave = () => {\n        //     expect(wg1.members.length).toEqual(1)\n        //     expect(wg1.members.includes(wg1.myId)).toBeTruthy()\n        //     queue.done()\n        //   }\n        //   // Code for peer 2\n        //   wg2.onStateChange = (state: WebGroupState) => {\n        //     if (state === WebGroup.LEFT) {\n        //       called2++\n        //       expect(wg2.members.length).toEqual(1)\n        //       expect(wg2.members.includes(wg2.myId)).toBeTruthy()\n        //       expect(wg2.key).toEqual('')\n        //       queue\n        //         .wait()\n        //         .then(() => wait(1000))\n        //         .then(() => {\n        //           expect(wg1.members.length).toEqual(1)\n        //           expect(wg1.members.includes(wg1.myId)).toBeTruthy()\n        //           expect(wg2.members.length).toEqual(1)\n        //           expect(wg2.members.includes(wg2.myId)).toBeTruthy()\n        //           expect(wg2.key).toEqual('')\n        //           expect(called2).toEqual(1)\n        //           expect(wg2.key).toEqual('')\n        //           done()\n        //         })\n        //     }\n        //   }\n        //   wg2.leave()\n        // })\n        // /** @test {WebGroup#onMemberLeave} */\n        // it('should be notified about left member', (done) => {\n        //   const queue = new Queue(2)\n        //   // Code for peer 1\n        //   wg1.onMemberLeave = (id) => {\n        //     expect(id).toEqual(wg2.myId)\n        //     called1++\n        //     queue.done()\n        //   }\n        //   // Code for peer 2\n        //   wg2.onMemberLeave = (id) => {\n        //     expect(id).toEqual(wg1.myId)\n        //     called2++\n        //     queue.done()\n        //   }\n        //   wg2.leave()\n        //   // When finish test\n        //   queue.wait().then(() => {\n        //     wait(1000).then(() => {\n        //       expect(called1).toEqual(1)\n        //       expect(called2).toEqual(1)\n        //       done()\n        //     })\n        //   })\n        // })\n        // /** @test {WebGroup#onStateChange} */\n        // it('should change the WebGroup state', (done) => {\n        //   // Code for peer 2\n        //   wg2.onStateChange = (state: WebGroupState) => {\n        //     if (state === WebGroup.LEFT) {\n        //       called2++\n        //     }\n        //     wait(1000).then(() => {\n        //       expect(called2).toEqual(1)\n        //       expect(wg2.state).toEqual(WebGroup.LEFT)\n        //       done()\n        //     })\n        //   }\n        //   wg2.leave()\n        // })\n        // /** @test {WebGroup#onSignalingStateChange} */\n        // it('should change the Signaling state', (done) => {\n        //   // Code for peer 2\n        //   wg2.onSignalingStateChange = (state: SignalingState) => {\n        //     if (state === SignalingState.CLOSED) {\n        //       called2++\n        //     }\n        //     wait(1000).then(() => {\n        //       expect(called2).toEqual(1)\n        //       expect(wg2.signalingState).toEqual(SignalingState.CLOSED)\n        //       done()\n        //     })\n        //   }\n        //   wg2.leave()\n        // })\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/3-clients.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 223,
    "kind": "test",
    "name": "describe151",
    "testId": 151,
    "memberof": "test/functional/3-clients.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151",
    "access": null,
    "description": "   - 3 clients",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 224,
    "kind": "test",
    "name": "describe152",
    "testId": 152,
    "memberof": "test/functional/3-clients.test.js~describe151",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe152",
    "access": null,
    "description": "join",
    "lineNumber": 14,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 225,
    "kind": "test",
    "name": "it153",
    "testId": 153,
    "memberof": "test/functional/3-clients.test.js~describe151.describe152",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe152.it153",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 51,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 226,
    "kind": "test",
    "name": "it154",
    "testId": 154,
    "memberof": "test/functional/3-clients.test.js~describe151.describe152",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe152.it154",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 77,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 227,
    "kind": "test",
    "name": "it155",
    "testId": 155,
    "memberof": "test/functional/3-clients.test.js~describe151.describe152",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe152.it155",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 102,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 228,
    "kind": "test",
    "name": "it156",
    "testId": 156,
    "memberof": "test/functional/3-clients.test.js~describe151.describe152",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe152.it156",
    "access": null,
    "description": "should have the same members, key, WebGroup id, topology once joined",
    "lineNumber": 136
  },
  {
    "__docId__": 229,
    "kind": "test",
    "name": "describe157",
    "testId": 157,
    "memberof": "test/functional/3-clients.test.js~describe151",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe157",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 167
  },
  {
    "__docId__": 230,
    "kind": "test",
    "name": "it158",
    "testId": 158,
    "memberof": "test/functional/3-clients.test.js~describe151.describe157",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe157.it158",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 212,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 231,
    "kind": "test",
    "name": "it159",
    "testId": 159,
    "memberof": "test/functional/3-clients.test.js~describe151.describe157",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe157.it159",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 260,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 232,
    "kind": "test",
    "name": "it160",
    "testId": 160,
    "memberof": "test/functional/3-clients.test.js~describe151.describe157",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe157.it160",
    "access": null,
    "description": "private String",
    "lineNumber": 311,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 233,
    "kind": "test",
    "name": "it161",
    "testId": 161,
    "memberof": "test/functional/3-clients.test.js~describe151.describe157",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3-clients.test.js~describe151.describe157.it161",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 365,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  }
]